{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to Competitive Programming Notes This website contains useful algorithms and problems that helps to prepare for coding interviews Topics Covered Arrays Strings Trees Graphs Dynamic Programming Greedy / BackTracking Sorting Binary Search","title":"Home"},{"location":"index.html#welcome-to-competitive-programming-notes","text":"This website contains useful algorithms and problems that helps to prepare for coding interviews","title":"Welcome to Competitive Programming Notes"},{"location":"index.html#topics-covered","text":"Arrays Strings Trees Graphs Dynamic Programming Greedy / BackTracking Sorting Binary Search","title":"Topics Covered"},{"location":"DynamicProgramming/index.html","text":"Dynamic Programming This pages act as home page for DP concepts Topics 1 Dimensional DP 2 Dimensional DP Partition Combinatorics Subsequences Digit DP Dp on Trees Dp on Graphs Dp on Strings Dp with Bitmasks Gametheory DP Dp with Advance DS","title":"Home"},{"location":"DynamicProgramming/index.html#dynamic-programming","text":"This pages act as home page for DP concepts","title":"Dynamic Programming"},{"location":"DynamicProgramming/index.html#topics","text":"1 Dimensional DP 2 Dimensional DP Partition Combinatorics Subsequences Digit DP Dp on Trees Dp on Graphs Dp on Strings Dp with Bitmasks Gametheory DP Dp with Advance DS","title":"Topics"},{"location":"DynamicProgramming/DigitDp.html","text":"Introduction It's Dynamic Programming Problem Involving digits. The digit problems will be based on some numbers, for eg: from l to r give me numbers which satisfy certain properties.","title":"Digit DP"},{"location":"DynamicProgramming/DigitDp.html#introduction","text":"It's Dynamic Programming Problem Involving digits. The digit problems will be based on some numbers, for eg: from l to r give me numbers which satisfy certain properties.","title":"Introduction"},{"location":"DynamicProgramming/Subsequences.html","text":"","title":"Subsequences"},{"location":"DynamicProgramming/Tree.html","tags":["tree"],"text":"Introduction dp[curr] --> indicates the answers for the subtree of curr. changes with the root of the tree Overall answer will not be changed(i.e on choosing any node to be root), if and only if in the question it is not mentioned any root. Answer will be dp[root]","title":"DP on Trees"},{"location":"DynamicProgramming/Tree.html#introduction","text":"dp[curr] --> indicates the answers for the subtree of curr. changes with the root of the tree Overall answer will not be changed(i.e on choosing any node to be root), if and only if in the question it is not mentioned any root. Answer will be dp[root]","title":"Introduction"},{"location":"DynamicProgramming/Problems/Categories.html","text":"Categories Basics of DP Fibonacci Number Climbing Stairs Min Cost Climbing Stairs One Dimensional DP Maximum Subarray House Robber House Robber-ii P Paint House P Paint House-ii Best time to buy and sell stock Best time to buy and sell stocks with transaction fee Best Time to Buy and Sell Stock with Cooldown Maximum Product Subarray P Max Consecutive Ones II Wiggle Subsequence P Maximum Subarray Sum After One Operation P Toss Strange Coins P Handshakes That Don't Cross Allocate Mailboxes Maximum Profit in Job Scheduling Maximum Number of Events That Can Be Attended II Best Time to Buy and Sell Stock III Best Time to Buy and Sell Stock IV Longest Valid Parenthesis Filling Bookcase Shelves Maximum Profit in Job Scheduling Maximum Number of Events That Can Be Attended II Animals Consecutive Subsequence DP on Strings Longest Common Subsequence Uncrossed Lines Longest Increasing Subsequence Minimum ASCII Delete Sum for Two Strings Number of Longest Increasing Subsequence Longest String Chain Maximum Length of Pair Chain Largest Divisible Subset Palindromic Substrings Longest Palindromic Substring P Shortest Way to Form String Longest Palindromic Subsequence P Longest Palindromic Subsequence - II P Minimum Window Subsequence P Valid Palindrome III Regular Expression Matching Shortest Common Supersequence P Longest Repeating Substring Edit Distance Minimum Number of Arrows to Burst Balloons Distinct Subsequences Non Overlapping Intervals DP on Counting Count Square Submatrices with All Ones Bomb Enemy Number of Dice Rolls With Target Sum Number of Ways to Stay in the Same Place After Some Steps Count All Possible Routes Number of Ways to Form a Target String Given a Dictionary Distinct Subsequences -II Number of Ways to Rearrange Sticks With K Sticks Visible Build Array Where You Can Find The Maximum Exactly K Comparisons Knight Probability in Chessboard P Number of Corner Rectangles P 4 Keys Keyboard P Find the Derangement of An Array P Count Ways to Distribute Candies P Sentence Screen Fitting DP on Trees Unique Binary Search Trees P Largest BST SubTree Minimum Cost Tree From Leaf Values P Delete Tree Nodes P Binary Tree Longest Consecutive Sequence II P House Robber III All Possible Full Binary Trees Binary Tree Maximum Path Sum","title":"Categories"},{"location":"DynamicProgramming/Problems/Categories.html#categories","text":"","title":"Categories"},{"location":"DynamicProgramming/Problems/Categories.html#basics-of-dp","text":"Fibonacci Number Climbing Stairs Min Cost Climbing Stairs","title":"Basics of DP"},{"location":"DynamicProgramming/Problems/Categories.html#one-dimensional-dp","text":"Maximum Subarray House Robber House Robber-ii P Paint House P Paint House-ii Best time to buy and sell stock Best time to buy and sell stocks with transaction fee Best Time to Buy and Sell Stock with Cooldown Maximum Product Subarray P Max Consecutive Ones II Wiggle Subsequence P Maximum Subarray Sum After One Operation P Toss Strange Coins P Handshakes That Don't Cross Allocate Mailboxes Maximum Profit in Job Scheduling Maximum Number of Events That Can Be Attended II Best Time to Buy and Sell Stock III Best Time to Buy and Sell Stock IV Longest Valid Parenthesis Filling Bookcase Shelves Maximum Profit in Job Scheduling Maximum Number of Events That Can Be Attended II Animals Consecutive Subsequence","title":"One Dimensional DP"},{"location":"DynamicProgramming/Problems/Categories.html#dp-on-strings","text":"Longest Common Subsequence Uncrossed Lines Longest Increasing Subsequence Minimum ASCII Delete Sum for Two Strings Number of Longest Increasing Subsequence Longest String Chain Maximum Length of Pair Chain Largest Divisible Subset Palindromic Substrings Longest Palindromic Substring P Shortest Way to Form String Longest Palindromic Subsequence P Longest Palindromic Subsequence - II P Minimum Window Subsequence P Valid Palindrome III Regular Expression Matching Shortest Common Supersequence P Longest Repeating Substring Edit Distance Minimum Number of Arrows to Burst Balloons Distinct Subsequences Non Overlapping Intervals","title":"DP on Strings"},{"location":"DynamicProgramming/Problems/Categories.html#dp-on-counting","text":"Count Square Submatrices with All Ones Bomb Enemy Number of Dice Rolls With Target Sum Number of Ways to Stay in the Same Place After Some Steps Count All Possible Routes Number of Ways to Form a Target String Given a Dictionary Distinct Subsequences -II Number of Ways to Rearrange Sticks With K Sticks Visible Build Array Where You Can Find The Maximum Exactly K Comparisons Knight Probability in Chessboard P Number of Corner Rectangles P 4 Keys Keyboard P Find the Derangement of An Array P Count Ways to Distribute Candies P Sentence Screen Fitting","title":"DP on Counting"},{"location":"DynamicProgramming/Problems/Categories.html#dp-on-trees","text":"Unique Binary Search Trees P Largest BST SubTree Minimum Cost Tree From Leaf Values P Delete Tree Nodes P Binary Tree Longest Consecutive Sequence II P House Robber III All Possible Full Binary Trees Binary Tree Maximum Path Sum","title":"DP on Trees"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/1273.delete-tree-nodes.html","tags":["DP","Trees","DFS"],"text":"Problem Statement A tree rooted at node 0 is given as follows: The number of nodes is nodes ; The value of the i<sup>th</sup> node is value[i] ; The parent of the i<sup>th</sup> node is parent[i] . Remove every subtree whose sum of values of nodes is zero. Return the number of the remaining nodes in the tree . Example 1: Input: nodes = 7, parent = [-1,0,0,1,2,2,2], value = [1,-2,4,0,-2,-1,-1] Output: 2 Example 2: Input: nodes = 7, parent = [-1,0,0,1,2,2,2], value = [1,-2,4,0,-2,-1,-2] Output: 6 Constraints: 1 <= nodes <= 10<sup>4</sup> parent.length == nodes 0 <= parent[i] <= nodes - 1 parent[0] == -1 which indicates that 0 is the root. value.length == nodes -10<sup>5</sup> <= value[i] <= 10<sup>5</sup> The given input is guaranteed to represent a valid tree . Solution class Solution : def deleteTreeNodes ( self , nodes : int , parent : List [ int ], value : List [ int ]) -> int : adj = defaultdict ( list ) for v , u in enumerate ( parent ): adj [ u ] . append ( v ) def dfs ( source ): total_val = value [ source ] total_elements = 1 for child in adj [ source ]: val , elements = dfs ( child ) total_val += val total_elements += elements if ( total_val == 0 ): return [ 0 , 0 ] return [ total_val , total_elements ] return dfs ( 0 )[ - 1 ]","title":"1273. Delete Tree Nodes"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/1273.delete-tree-nodes.html#problem-statement","text":"A tree rooted at node 0 is given as follows: The number of nodes is nodes ; The value of the i<sup>th</sup> node is value[i] ; The parent of the i<sup>th</sup> node is parent[i] . Remove every subtree whose sum of values of nodes is zero. Return the number of the remaining nodes in the tree . Example 1: Input: nodes = 7, parent = [-1,0,0,1,2,2,2], value = [1,-2,4,0,-2,-1,-1] Output: 2 Example 2: Input: nodes = 7, parent = [-1,0,0,1,2,2,2], value = [1,-2,4,0,-2,-1,-2] Output: 6 Constraints: 1 <= nodes <= 10<sup>4</sup> parent.length == nodes 0 <= parent[i] <= nodes - 1 parent[0] == -1 which indicates that 0 is the root. value.length == nodes -10<sup>5</sup> <= value[i] <= 10<sup>5</sup> The given input is guaranteed to represent a valid tree .","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/1273.delete-tree-nodes.html#solution","text":"class Solution : def deleteTreeNodes ( self , nodes : int , parent : List [ int ], value : List [ int ]) -> int : adj = defaultdict ( list ) for v , u in enumerate ( parent ): adj [ u ] . append ( v ) def dfs ( source ): total_val = value [ source ] total_elements = 1 for child in adj [ source ]: val , elements = dfs ( child ) total_val += val total_elements += elements if ( total_val == 0 ): return [ 0 , 0 ] return [ total_val , total_elements ] return dfs ( 0 )[ - 1 ]","title":"Solution"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/2313.min-flips-in-binary-tree-to-get-result.html","tags":["DP","Hard","Premium","Leetcode"],"text":"Problem Statement You are given the root of a binary tree with the following properties: Leaf nodes have either the value 0 or 1 , representing false and true respectively. Non-leaf nodes have either the value 2 , 3 , 4 , or 5 , representing the boolean operations OR , AND , XOR , and NOT , respectively. You are also given a boolean result , which is the desired result of the evaluation of the root node. The evaluation of a node is as follows: If the node is a leaf node, the evaluation is the value of the node, i.e. true or false . Otherwise, evaluate the node's children and apply the boolean operation of its value with the children's evaluations. In one operation, you can flip a leaf node, which causes a false node to become true , and a true node to become false . Return the minimum number of operations that need to be performed such that the evaluation of root yields result . It can be shown that there is always a way to achieve result . A leaf node is a node that has zero children. Note: NOT nodes have either a left child or a right child, but other non-leaf nodes have both a left child and a right child. Example 1: Input: root = [3,5,4,2,null,1,1,1,0], result = true Output: 2 Explanation: It can be shown that a minimum of 2 nodes have to be flipped to make the root of the tree evaluate to true. One way to achieve this is shown in the diagram above. Example 2: Input: root = [0], result = false Output: 0 Explanation: The root of the tree already evaluates to false, so 0 nodes have to be flipped. Constraints: The number of nodes in the tree is in the range [1, 10<sup>5</sup>] . 0 <= Node.val <= 5 OR , AND , and XOR nodes have 2 children. NOT nodes have 1 child. Leaf nodes have a value of 0 or 1 . Non-leaf nodes have a value of 2 , 3 , 4 , or 5 . Solution class Solution : def minimumFlips ( self , root : Optional [ TreeNode ], result : bool ) -> int : @lru_cache ( maxsize = None ) def min_operations ( root , result ): if ( not root ): return 0 if ( root . val <= 1 ): return 1 if ( root . val != result ) else 0 if ( root . val == 4 ): if ( result ): return min ( min_operations ( root . left , True ) + min_operations ( root . right , False ), min_operations ( root . left , False ) + min_operations ( root . right , True )) else : return min ( min_operations ( root . left , False ) + min_operations ( root . right , False ), min_operations ( root . left , True ) + min_operations ( root . right , True )) if ( root . val == 2 ): if ( not result ): return min_operations ( root . left , False ) + min_operations ( root . right , False ) else : return min ( min_operations ( root . left , False ) + min_operations ( root . right , True ), min_operations ( root . left , True ) + min_operations ( root . right , True ), min_operations ( root . left , True ) + min_operations ( root . right , False )) if ( root . val == 3 ): if ( result ): return min_operations ( root . left , True ) + min_operations ( root . right , True ) else : return min ( min_operations ( root . left , False ) + min_operations ( root . right , True ), min_operations ( root . left , False ) + min_operations ( root . right , False ), min_operations ( root . left , True ) + min_operations ( root . right , False )) return min_operations ( root . left , not result ) + min_operations ( root . right , not result ) return min_operations ( root , result )","title":"2313. Minimum Flips in Binary Tree to Get Result"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/2313.min-flips-in-binary-tree-to-get-result.html#problem-statement","text":"You are given the root of a binary tree with the following properties: Leaf nodes have either the value 0 or 1 , representing false and true respectively. Non-leaf nodes have either the value 2 , 3 , 4 , or 5 , representing the boolean operations OR , AND , XOR , and NOT , respectively. You are also given a boolean result , which is the desired result of the evaluation of the root node. The evaluation of a node is as follows: If the node is a leaf node, the evaluation is the value of the node, i.e. true or false . Otherwise, evaluate the node's children and apply the boolean operation of its value with the children's evaluations. In one operation, you can flip a leaf node, which causes a false node to become true , and a true node to become false . Return the minimum number of operations that need to be performed such that the evaluation of root yields result . It can be shown that there is always a way to achieve result . A leaf node is a node that has zero children. Note: NOT nodes have either a left child or a right child, but other non-leaf nodes have both a left child and a right child. Example 1: Input: root = [3,5,4,2,null,1,1,1,0], result = true Output: 2 Explanation: It can be shown that a minimum of 2 nodes have to be flipped to make the root of the tree evaluate to true. One way to achieve this is shown in the diagram above. Example 2: Input: root = [0], result = false Output: 0 Explanation: The root of the tree already evaluates to false, so 0 nodes have to be flipped. Constraints: The number of nodes in the tree is in the range [1, 10<sup>5</sup>] . 0 <= Node.val <= 5 OR , AND , and XOR nodes have 2 children. NOT nodes have 1 child. Leaf nodes have a value of 0 or 1 . Non-leaf nodes have a value of 2 , 3 , 4 , or 5 .","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/2313.min-flips-in-binary-tree-to-get-result.html#solution","text":"class Solution : def minimumFlips ( self , root : Optional [ TreeNode ], result : bool ) -> int : @lru_cache ( maxsize = None ) def min_operations ( root , result ): if ( not root ): return 0 if ( root . val <= 1 ): return 1 if ( root . val != result ) else 0 if ( root . val == 4 ): if ( result ): return min ( min_operations ( root . left , True ) + min_operations ( root . right , False ), min_operations ( root . left , False ) + min_operations ( root . right , True )) else : return min ( min_operations ( root . left , False ) + min_operations ( root . right , False ), min_operations ( root . left , True ) + min_operations ( root . right , True )) if ( root . val == 2 ): if ( not result ): return min_operations ( root . left , False ) + min_operations ( root . right , False ) else : return min ( min_operations ( root . left , False ) + min_operations ( root . right , True ), min_operations ( root . left , True ) + min_operations ( root . right , True ), min_operations ( root . left , True ) + min_operations ( root . right , False )) if ( root . val == 3 ): if ( result ): return min_operations ( root . left , True ) + min_operations ( root . right , True ) else : return min ( min_operations ( root . left , False ) + min_operations ( root . right , True ), min_operations ( root . left , False ) + min_operations ( root . right , False ), min_operations ( root . left , True ) + min_operations ( root . right , False )) return min_operations ( root . left , not result ) + min_operations ( root . right , not result ) return min_operations ( root , result )","title":"Solution"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/333.largest-bst-subtree.html","tags":["Premium","Dp","Trees"],"text":"Problem Statement Given the root of a binary tree, find the largest , which is also a Binary Search Tree (BST), where the largest means subtree has the largest number of nodes. A Binary Search Tree (BST) is a tree in which all the nodes follow the below-mentioned properties: The left subtree values are less than the value of their parent (root) node's value. The right subtree values are greater than the value of their parent (root) node's value. Note: A subtree must include all of its descendants. Example 1: Input: root = [10,5,15,1,8,null,7] Output: 3 Explanation: The Largest BST Subtree in this case is the highlighted one. The return value is the subtree's size, which is 3. Example 2: Input: root = [4,2,7,2,3,5,null,2,null,null,null,null,null,1] Output: 2 Constraints: The number of nodes in the tree is in the range [0, 10<sup>4</sup>] . -10<sup>4</sup> <= Node.val <= 10<sup>4</sup> Follow up: Can you figure out ways to solve it with O(n) time complexity? # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def largestBSTSubtree ( self , root : Optional [ TreeNode ]) -> int : def traverse ( root ): if ( not root ): return [ float ( \"Inf\" ), - float ( \"Inf\" ), 0 ] # min, max, count left = traverse ( root . left ) right = traverse ( root . right ) if ( root . val > left [ 1 ] and root . val < right [ 0 ]): return [ min ( root . val , left [ 0 ]), max ( root . val , right [ 1 ]), left [ - 1 ] + right [ - 1 ] + 1 ] return [ - float ( \"Inf\" ), float ( \"Inf\" ), max ( left [ - 1 ], right [ - 1 ])] return traverse ( root )[ - 1 ]","title":"333. Largest BST Subtree"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/333.largest-bst-subtree.html#problem-statement","text":"Given the root of a binary tree, find the largest , which is also a Binary Search Tree (BST), where the largest means subtree has the largest number of nodes. A Binary Search Tree (BST) is a tree in which all the nodes follow the below-mentioned properties: The left subtree values are less than the value of their parent (root) node's value. The right subtree values are greater than the value of their parent (root) node's value. Note: A subtree must include all of its descendants. Example 1: Input: root = [10,5,15,1,8,null,7] Output: 3 Explanation: The Largest BST Subtree in this case is the highlighted one. The return value is the subtree's size, which is 3. Example 2: Input: root = [4,2,7,2,3,5,null,2,null,null,null,null,null,1] Output: 2 Constraints: The number of nodes in the tree is in the range [0, 10<sup>4</sup>] . -10<sup>4</sup> <= Node.val <= 10<sup>4</sup> Follow up: Can you figure out ways to solve it with O(n) time complexity? # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def largestBSTSubtree ( self , root : Optional [ TreeNode ]) -> int : def traverse ( root ): if ( not root ): return [ float ( \"Inf\" ), - float ( \"Inf\" ), 0 ] # min, max, count left = traverse ( root . left ) right = traverse ( root . right ) if ( root . val > left [ 1 ] and root . val < right [ 0 ]): return [ min ( root . val , left [ 0 ]), max ( root . val , right [ 1 ]), left [ - 1 ] + right [ - 1 ] + 1 ] return [ - float ( \"Inf\" ), float ( \"Inf\" ), max ( left [ - 1 ], right [ - 1 ])] return traverse ( root )[ - 1 ]","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/337.house-robber-iii.html","tags":["DP","Trees","Premium"],"text":"Problem Statement The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root . Besides the root , each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night . Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police . Example 1: Input: root = [3,2,3,null,3,null,1] Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input: root = [3,4,5,1,3,null,1] Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. Constraints: The number of nodes in the tree is in the range [1, 10<sup>4</sup>] . 0 <= Node.val <= 10<sup>4</sup> Solution class Solution : def rob ( self , root : Optional [ TreeNode ]) -> int : # 0 - inclusive 1 - exclusive def dfs ( root ): if ( not root ): return [ 0 , 0 ] left = dfs ( root . left ) right = dfs ( root . right ) inc , exc = root . val + left [ - 1 ] + right [ - 1 ], max ( left ) + max ( right ) return [ inc , exc ] return max ( dfs ( root ))","title":"337. House Robber III"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/337.house-robber-iii.html#problem-statement","text":"The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root . Besides the root , each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night . Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police . Example 1: Input: root = [3,2,3,null,3,null,1] Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input: root = [3,4,5,1,3,null,1] Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. Constraints: The number of nodes in the tree is in the range [1, 10<sup>4</sup>] . 0 <= Node.val <= 10<sup>4</sup>","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/337.house-robber-iii.html#solution","text":"class Solution : def rob ( self , root : Optional [ TreeNode ]) -> int : # 0 - inclusive 1 - exclusive def dfs ( root ): if ( not root ): return [ 0 , 0 ] left = dfs ( root . left ) right = dfs ( root . right ) inc , exc = root . val + left [ - 1 ] + right [ - 1 ], max ( left ) + max ( right ) return [ inc , exc ] return max ( dfs ( root ))","title":"Solution"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/549.binary-tree-longest-consecutive-sequence-ii.html","tags":["DP","Trees","DFS","Premium"],"text":"Problem Statement Given the root of a binary tree, return the length of the longest consecutive path in the tree . A consecutive path is a path where the values of the consecutive nodes in the path differ by one. This path can be either increasing or decreasing. For example, [1,2,3,4] and [4,3,2,1] are both considered valid, but the path [1,2,4,3] is not valid. On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order. Example 1: Input: root = [1,2,3] Output: 2 Explanation: The longest consecutive path is [1, 2] or [2, 1]. Example 2: Input: root = [2,1,3] Output: 3 Explanation: The longest consecutive path is [1, 2, 3] or [3, 2, 1]. Constraints: The number of nodes in the tree is in the range [1, 3 * 10<sup>4</sup>] . -3 * 10<sup>4</sup> <= Node.val <= 3 * 10<sup>4</sup> Solution # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def longestConsecutive ( self , root : Optional [ TreeNode ]) -> int : max_length = [ 1 ] def dfs ( root ): if ( not root ): return [ 0 , 0 ] if ( not root . left and not root . right ): return [ 1 , 1 ] left = dfs ( root . left ) left [ 0 ], left [ 1 ] = left [ 0 ] + 1 , left [ 1 ] + 1 right = dfs ( root . right ) right [ 0 ], right [ 1 ] = right [ 0 ] + 1 , right [ 1 ] + 1 if ( root . left ): if ( root . left . val + 1 != root . val ): left [ 0 ] = 1 if ( root . left . val - 1 != root . val ): left [ - 1 ] = 1 if ( root . right ): if ( root . right . val + 1 != root . val ): right [ 0 ] = 1 if ( root . right . val - 1 != root . val ): right [ - 1 ] = 1 max_length [ 0 ] = max ( left [ 0 ] + right [ - 1 ] - 1 , max_length [ 0 ], left [ 1 ] + right [ 0 ] - 1 ) return [ max ( left [ 0 ], right [ 0 ]), max ( left [ 1 ], right [ 1 ])] dfs ( root ) return max_length [ 0 ]","title":"549. Binary Tree Longest Consecutive Sequence II"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/549.binary-tree-longest-consecutive-sequence-ii.html#problem-statement","text":"Given the root of a binary tree, return the length of the longest consecutive path in the tree . A consecutive path is a path where the values of the consecutive nodes in the path differ by one. This path can be either increasing or decreasing. For example, [1,2,3,4] and [4,3,2,1] are both considered valid, but the path [1,2,4,3] is not valid. On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order. Example 1: Input: root = [1,2,3] Output: 2 Explanation: The longest consecutive path is [1, 2] or [2, 1]. Example 2: Input: root = [2,1,3] Output: 3 Explanation: The longest consecutive path is [1, 2, 3] or [3, 2, 1]. Constraints: The number of nodes in the tree is in the range [1, 3 * 10<sup>4</sup>] . -3 * 10<sup>4</sup> <= Node.val <= 3 * 10<sup>4</sup>","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/549.binary-tree-longest-consecutive-sequence-ii.html#solution","text":"# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def longestConsecutive ( self , root : Optional [ TreeNode ]) -> int : max_length = [ 1 ] def dfs ( root ): if ( not root ): return [ 0 , 0 ] if ( not root . left and not root . right ): return [ 1 , 1 ] left = dfs ( root . left ) left [ 0 ], left [ 1 ] = left [ 0 ] + 1 , left [ 1 ] + 1 right = dfs ( root . right ) right [ 0 ], right [ 1 ] = right [ 0 ] + 1 , right [ 1 ] + 1 if ( root . left ): if ( root . left . val + 1 != root . val ): left [ 0 ] = 1 if ( root . left . val - 1 != root . val ): left [ - 1 ] = 1 if ( root . right ): if ( root . right . val + 1 != root . val ): right [ 0 ] = 1 if ( root . right . val - 1 != root . val ): right [ - 1 ] = 1 max_length [ 0 ] = max ( left [ 0 ] + right [ - 1 ] - 1 , max_length [ 0 ], left [ 1 ] + right [ 0 ] - 1 ) return [ max ( left [ 0 ], right [ 0 ]), max ( left [ 1 ], right [ 1 ])] dfs ( root ) return max_length [ 0 ]","title":"Solution"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/vertex-cover.html","tags":["DP","Spoj"],"text":"Problem Statement You are given an unweighted, undirected tree. Write a program to find a vertex set of minimum size in this tree such that each edge has as least one of its end-points in that set. Solve Input The first line of the input file contains one integer N --- number of nodes in the tree (0 < N <= 100000). Next N -1 lines contain N -1 edges of that tree --- Each line contains a pair ( u , v ) means there is an edge between node u and node v (1 <= u , v <= N ). Output Print number of nodes in the satisfied vertex set on one line. Example 1 Input: 3 1 2 1 3 Output: 1 Explanation: The set can be {1} Example 2 Input: 3 1 2 2 3 Output: 1 Explanation: The set can be {2} Explanation For every node we have 2 options, we include it in the set or not dp[curr][0] -> vertex cover if current node is not in the set of the subtree dp[curr][1] -> vertex cover if the current node is chosen in the set of the subtree for leaf nodes dp[leaf][0] = 0 dp[leaf][1] = 1 Solution from collections import defaultdict n = int ( input ()) adj = defaultdict ( list ) dp = [[ 0 ] * 2 for _ in range ( n + 1 )] def find_min_vertex ( source , parent ): dp [ source ][ 0 ] = 0 dp [ source ][ 1 ] = 1 for child in adj [ source ]: if ( child != parent ): find_min_vertex ( child , source ) dp [ source ][ 0 ] += dp [ child ][ 1 ] dp [ source ][ 1 ] += min ( dp [ child ][ 0 ], dp [ child ][ 1 ]) for i in range ( n - 1 ): u , v = map ( int , input () . split ()) adj [ u ] . append ( v ) adj [ v ] . append ( u ) find_min_vertex ( 1 , - 1 ) print ( min ( dp [ 1 ][ 1 ], dp [ 1 ][ 0 ]))","title":"PT07X - Vertex Cover"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/vertex-cover.html#problem-statement","text":"You are given an unweighted, undirected tree. Write a program to find a vertex set of minimum size in this tree such that each edge has as least one of its end-points in that set. Solve","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/vertex-cover.html#input","text":"The first line of the input file contains one integer N --- number of nodes in the tree (0 < N <= 100000). Next N -1 lines contain N -1 edges of that tree --- Each line contains a pair ( u , v ) means there is an edge between node u and node v (1 <= u , v <= N ).","title":"Input"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/vertex-cover.html#output","text":"Print number of nodes in the satisfied vertex set on one line.","title":"Output"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/vertex-cover.html#example-1","text":"Input: 3 1 2 1 3 Output: 1 Explanation: The set can be {1}","title":"Example 1"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/vertex-cover.html#example-2","text":"Input: 3 1 2 2 3 Output: 1 Explanation: The set can be {2}","title":"Example 2"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/vertex-cover.html#explanation","text":"For every node we have 2 options, we include it in the set or not dp[curr][0] -> vertex cover if current node is not in the set of the subtree dp[curr][1] -> vertex cover if the current node is chosen in the set of the subtree for leaf nodes dp[leaf][0] = 0 dp[leaf][1] = 1","title":"Explanation"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/vertex-cover.html#solution","text":"from collections import defaultdict n = int ( input ()) adj = defaultdict ( list ) dp = [[ 0 ] * 2 for _ in range ( n + 1 )] def find_min_vertex ( source , parent ): dp [ source ][ 0 ] = 0 dp [ source ][ 1 ] = 1 for child in adj [ source ]: if ( child != parent ): find_min_vertex ( child , source ) dp [ source ][ 0 ] += dp [ child ][ 1 ] dp [ source ][ 1 ] += min ( dp [ child ][ 0 ], dp [ child ][ 1 ]) for i in range ( n - 1 ): u , v = map ( int , input () . split ()) adj [ u ] . append ( v ) adj [ v ] . append ( u ) find_min_vertex ( 1 , - 1 ) print ( min ( dp [ 1 ][ 1 ], dp [ 1 ][ 0 ]))","title":"Solution"},{"location":"DynamicProgramming/Problems/One-Dimensional/1230.toss-strange-coins.html","tags":["DP","Medium","1D"],"text":"Problem Statement To continue using LeetCode Video solutions extension , you have to switch to the old layout of LeetCode (for now). I am working on releasing the new version soon which works with LeetCode's new UI. How to switch to old UI easily: 1. Ensure that \"Opt-in for further beta testing\" is turned ON here . 2. On this problem page, on the top-right of your screen, click on your profile picture and select \"Revert to old version\". Above way didn't work? (click me) (scroll below) Go to Problems List page . On the bottom-right, click on the \"revert\" icon as shown below then refresh this page: Solution class Solution : def probabilityOfHeads ( self , prob : List [ float ], target : int ) -> float : dp = [[ 0 ] * ( target + 1 ) for _ in range ( len ( prob ) + 1 )] dp [ 0 ][ 0 ] = 1 for i in range ( 1 , len ( prob ) + 1 ): for j in range ( 0 , target + 1 ): dp [ i ][ j ] = ( 1 - prob [ i - 1 ]) * dp [ i - 1 ][ j ] if ( j > 0 ): dp [ i ][ j ] += prob [ i - 1 ] * dp [ i - 1 ][ j - 1 ] return dp [ len ( prob )][ target ]","title":"1230.toss strange coins"},{"location":"DynamicProgramming/Problems/One-Dimensional/1230.toss-strange-coins.html#problem-statement","text":"To continue using LeetCode Video solutions extension , you have to switch to the old layout of LeetCode (for now). I am working on releasing the new version soon which works with LeetCode's new UI.","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/One-Dimensional/1230.toss-strange-coins.html#_1","text":"How to switch to old UI easily: 1. Ensure that \"Opt-in for further beta testing\" is turned ON here . 2. On this problem page, on the top-right of your screen, click on your profile picture and select \"Revert to old version\". Above way didn't work? (click me) (scroll below) Go to Problems List page . On the bottom-right, click on the \"revert\" icon as shown below then refresh this page:","title":""},{"location":"DynamicProgramming/Problems/One-Dimensional/1230.toss-strange-coins.html#solution","text":"class Solution : def probabilityOfHeads ( self , prob : List [ float ], target : int ) -> float : dp = [[ 0 ] * ( target + 1 ) for _ in range ( len ( prob ) + 1 )] dp [ 0 ][ 0 ] = 1 for i in range ( 1 , len ( prob ) + 1 ): for j in range ( 0 , target + 1 ): dp [ i ][ j ] = ( 1 - prob [ i - 1 ]) * dp [ i - 1 ][ j ] if ( j > 0 ): dp [ i ][ j ] += prob [ i - 1 ] * dp [ i - 1 ][ j - 1 ] return dp [ len ( prob )][ target ]","title":"Solution"},{"location":"DynamicProgramming/Problems/One-Dimensional/1746.maximum-subarray-sum-after-one-operation.html","tags":["DP","Medium","1D"],"text":"Problem Statement You are given an integer array nums . You must perform exactly one operation where you can replace one element nums[i] with nums[i] * nums[i] . Return the maximum possible subarray sum after exactly one operation . The subarray must be non-empty. Example 1: Input: nums = [2,-1,-4,-3] Output: 17 Explanation: You can perform the operation on index 2 (0-indexed) to make nums = [2,-1,16,-3]. Now, the maximum subarray sum is 2 + -1 + 16 = 17. Example 2: Input: nums = [1,-1,1,1,-1,-1,1] Output: 4 Explanation: You can perform the operation on index 1 (0-indexed) to make nums = [1,1,1,1,-1,-1,1]. Now, the maximum subarray sum is 1 + 1 + 1 + 1 = 4. Constraints: 1 <= nums.length <= 10<sup>5</sup> -10<sup>4</sup> <= nums[i] <= 10<sup>4</sup> Solution class Solution : def maxSumAfterOperation ( self , nums : List [ int ]) -> int : result = 0 dp = [ 0 , 0 ] for i in range ( 0 , len ( nums )): dp [ 1 ] = max ( nums [ i ] * nums [ i ] + dp [ 0 ] , dp [ 1 ] + nums [ i ]) dp [ 0 ] = max ( 0 , dp [ 0 ] + nums [ i ]) result = max ( result , dp [ 1 ]) return result","title":"1746.maximum subarray sum after one operation"},{"location":"DynamicProgramming/Problems/One-Dimensional/1746.maximum-subarray-sum-after-one-operation.html#problem-statement","text":"You are given an integer array nums . You must perform exactly one operation where you can replace one element nums[i] with nums[i] * nums[i] . Return the maximum possible subarray sum after exactly one operation . The subarray must be non-empty. Example 1: Input: nums = [2,-1,-4,-3] Output: 17 Explanation: You can perform the operation on index 2 (0-indexed) to make nums = [2,-1,16,-3]. Now, the maximum subarray sum is 2 + -1 + 16 = 17. Example 2: Input: nums = [1,-1,1,1,-1,-1,1] Output: 4 Explanation: You can perform the operation on index 1 (0-indexed) to make nums = [1,1,1,1,-1,-1,1]. Now, the maximum subarray sum is 1 + 1 + 1 + 1 = 4. Constraints: 1 <= nums.length <= 10<sup>5</sup> -10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/One-Dimensional/1746.maximum-subarray-sum-after-one-operation.html#solution","text":"class Solution : def maxSumAfterOperation ( self , nums : List [ int ]) -> int : result = 0 dp = [ 0 , 0 ] for i in range ( 0 , len ( nums )): dp [ 1 ] = max ( nums [ i ] * nums [ i ] + dp [ 0 ] , dp [ 1 ] + nums [ i ]) dp [ 0 ] = max ( 0 , dp [ 0 ] + nums [ i ]) result = max ( result , dp [ 1 ]) return result","title":"Solution"},{"location":"DynamicProgramming/Problems/One-Dimensional/256.paint-house.html","tags":["DP","Medium","1D"],"text":"Problem Statement There is a row of n houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by an n x 3 cost matrix costs . For example, costs[0][0] is the cost of painting house 0 with the color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Return the minimum cost to paint all houses . Example 1: Input: costs = [[17,2,17],[16,16,5],[14,3,19]] Output: 10 Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue. Minimum cost: 2 + 5 + 3 = 10. Example 2: Input: costs = [[7,6,2]] Output: 2 Constraints: costs.length == n costs[i].length == 3 1 <= n <= 100 1 <= costs[i][j] <= 20 Solution class Solution : def minCost ( self , costs : List [ List [ int ]]) -> int : for i in range ( len ( costs ) - 2 , - 1 , - 1 ): for j in range ( 0 , 3 ): costs [ i ][ j ] += min ( costs [ i + 1 ][( j + 1 ) % 3 ], costs [ i + 1 ][( j + 2 ) % 3 ]) return min ( costs [ 0 ])","title":"256.paint house"},{"location":"DynamicProgramming/Problems/One-Dimensional/256.paint-house.html#problem-statement","text":"There is a row of n houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by an n x 3 cost matrix costs . For example, costs[0][0] is the cost of painting house 0 with the color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Return the minimum cost to paint all houses . Example 1: Input: costs = [[17,2,17],[16,16,5],[14,3,19]] Output: 10 Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue. Minimum cost: 2 + 5 + 3 = 10. Example 2: Input: costs = [[7,6,2]] Output: 2 Constraints: costs.length == n costs[i].length == 3 1 <= n <= 100 1 <= costs[i][j] <= 20","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/One-Dimensional/256.paint-house.html#solution","text":"class Solution : def minCost ( self , costs : List [ List [ int ]]) -> int : for i in range ( len ( costs ) - 2 , - 1 , - 1 ): for j in range ( 0 , 3 ): costs [ i ][ j ] += min ( costs [ i + 1 ][( j + 1 ) % 3 ], costs [ i + 1 ][( j + 2 ) % 3 ]) return min ( costs [ 0 ])","title":"Solution"},{"location":"DynamicProgramming/Problems/One-Dimensional/265.paint-house-ii.html","tags":["DP","Hard","1D"],"text":"Problem Statement There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by an n x k cost matrix costs. For example, costs[0][0] is the cost of painting house 0 with color 0 ; costs[1][2] is the cost of painting house 1 with color 2 , and so on... Return the minimum cost to paint all houses . Example 1: Input: costs = [[1,5,3],[2,9,4]] Output: 5 Explanation: Paint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; Or paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5. Example 2: Input: costs = [[1,3],[2,4]] Output: 5 Constraints: costs.length == n costs[i].length == k 1 <= n <= 100 2 <= k <= 20 1 <= costs[i][j] <= 20 Follow up: Could you solve it in O(nk) runtime? Solution class Solution : def minCostII ( self , costs : List [ List [ int ]]) -> int : first_min = 0 second_min = 1 for i in range ( 0 , len ( costs [ 0 ])): if ( costs [ - 1 ][ i ] < costs [ - 1 ][ first_min ]): second_min = first_min first_min = i elif ( costs [ - 1 ][ i ] < costs [ - 1 ][ second_min ] and i != first_min ): second_min = i print ( first_min , second_min ) for i in range ( len ( costs ) - 2 , - 1 , - 1 ): new_first_min = None new_second_min = None for j in range ( 0 , len ( costs [ 0 ])): if ( first_min != j ): costs [ i ][ j ] += costs [ i + 1 ][ first_min ] else : costs [ i ][ j ] += costs [ i + 1 ][ second_min ] if ( new_first_min == None or costs [ i ][ j ] < costs [ i ][ new_first_min ]): new_second_min = new_first_min new_first_min = j elif ( new_second_min == None or costs [ i ][ j ] < costs [ i ][ new_second_min ]): new_second_min = j first_min = new_first_min second_min = new_second_min return min ( costs [ 0 ])","title":"265.paint house ii"},{"location":"DynamicProgramming/Problems/One-Dimensional/265.paint-house-ii.html#problem-statement","text":"There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by an n x k cost matrix costs. For example, costs[0][0] is the cost of painting house 0 with color 0 ; costs[1][2] is the cost of painting house 1 with color 2 , and so on... Return the minimum cost to paint all houses . Example 1: Input: costs = [[1,5,3],[2,9,4]] Output: 5 Explanation: Paint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; Or paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5. Example 2: Input: costs = [[1,3],[2,4]] Output: 5 Constraints: costs.length == n costs[i].length == k 1 <= n <= 100 2 <= k <= 20 1 <= costs[i][j] <= 20 Follow up: Could you solve it in O(nk) runtime?","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/One-Dimensional/265.paint-house-ii.html#solution","text":"class Solution : def minCostII ( self , costs : List [ List [ int ]]) -> int : first_min = 0 second_min = 1 for i in range ( 0 , len ( costs [ 0 ])): if ( costs [ - 1 ][ i ] < costs [ - 1 ][ first_min ]): second_min = first_min first_min = i elif ( costs [ - 1 ][ i ] < costs [ - 1 ][ second_min ] and i != first_min ): second_min = i print ( first_min , second_min ) for i in range ( len ( costs ) - 2 , - 1 , - 1 ): new_first_min = None new_second_min = None for j in range ( 0 , len ( costs [ 0 ])): if ( first_min != j ): costs [ i ][ j ] += costs [ i + 1 ][ first_min ] else : costs [ i ][ j ] += costs [ i + 1 ][ second_min ] if ( new_first_min == None or costs [ i ][ j ] < costs [ i ][ new_first_min ]): new_second_min = new_first_min new_first_min = j elif ( new_second_min == None or costs [ i ][ j ] < costs [ i ][ new_second_min ]): new_second_min = j first_min = new_first_min second_min = new_second_min return min ( costs [ 0 ])","title":"Solution"},{"location":"DynamicProgramming/Problems/One-Dimensional/487.Max-Consecutive-Ones-II.html","tags":["DP","Medium","1D"],"text":"Problem Statement Given a binary array nums , return the maximum number of consecutive 1 's in the array if you can flip at most one 0 . Example 1: Input: nums = [1,0,1,1,0] Output: 4 Explanation: - If we flip the first zero, nums becomes [1,1,1,1,0] and we have 4 consecutive ones. - If we flip the second zero, nums becomes [1,0,1,1,1] and we have 3 consecutive ones. The max number of consecutive ones is 4. Example 2: Input: nums = [1,0,1,1,0,1] Output: 4 Explanation: - If we flip the first zero, nums becomes [1,1,1,1,0,1] and we have 4 consecutive ones. - If we flip the second zero, nums becomes [1,0,1,1,1,1] and we have 4 consecutive ones. The max number of consecutive ones is 4. Constraints: 1 <= nums.length <= 10<sup>5</sup> nums[i] is either 0 or 1 . Follow up: What if the input numbers come in one by one as an infinite stream? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently? Solution class Solution : def findMaxConsecutiveOnes ( self , nums : List [ int ]) -> int : cur_index , next_index , ans = - 1 , None , 0 for i in range ( len ( nums )): if ( nums [ i ] == 0 ): if ( next_index == None ): next_index = i else : cur_index , next_index = next_index , i ans = max ( ans , i - cur_index ) return ans","title":"487.Max Consecutive Ones II"},{"location":"DynamicProgramming/Problems/One-Dimensional/487.Max-Consecutive-Ones-II.html#problem-statement","text":"Given a binary array nums , return the maximum number of consecutive 1 's in the array if you can flip at most one 0 . Example 1: Input: nums = [1,0,1,1,0] Output: 4 Explanation: - If we flip the first zero, nums becomes [1,1,1,1,0] and we have 4 consecutive ones. - If we flip the second zero, nums becomes [1,0,1,1,1] and we have 3 consecutive ones. The max number of consecutive ones is 4. Example 2: Input: nums = [1,0,1,1,0,1] Output: 4 Explanation: - If we flip the first zero, nums becomes [1,1,1,1,0,1] and we have 4 consecutive ones. - If we flip the second zero, nums becomes [1,0,1,1,1,1] and we have 4 consecutive ones. The max number of consecutive ones is 4. Constraints: 1 <= nums.length <= 10<sup>5</sup> nums[i] is either 0 or 1 . Follow up: What if the input numbers come in one by one as an infinite stream? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently?","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/One-Dimensional/487.Max-Consecutive-Ones-II.html#solution","text":"class Solution : def findMaxConsecutiveOnes ( self , nums : List [ int ]) -> int : cur_index , next_index , ans = - 1 , None , 0 for i in range ( len ( nums )): if ( nums [ i ] == 0 ): if ( next_index == None ): next_index = i else : cur_index , next_index = next_index , i ans = max ( ans , i - cur_index ) return ans","title":"Solution"},{"location":"GFG-Contests/weekly-contest-103/K-periodic-circular-string.html","tags":["Strings","Contest","HashMap"],"text":"A K -periodic circular string is a circular string which remains same when it is rotated by K units. Given a circular string s , find whether there exists a permuation of s which is a K-periodic circular string and if it exists then find lexicographically smallest permuation of s which is a K-periodic circular string. Return empty string if there does not exist a valid permutation of s which is a K-periodic circular string. Note : You can rotate string in any direction. Example 1: Input: s = \"abba\" K = 2 Output: abab Explanation: \"abab\" when rotated by 2 units remains same. Example 2: Input: s = \"abbbbbb\" K = 4 Output: -1 Explanation: No permuation of s can be a 4-periodic circular string. Your Task: You don't need to read input or print anything. Your task is to complete the function kPeriodic() which takes the string s and integer K as input parameters and returns the lexicographically smallest permuation of s which is a K-periodic circular string if it exists, else returns an empty string, the driver code will print \"-1\" in that case. Expected Time Complexity: O(|s|) Expected Auxiliary Space: O(|s|) Constraints: 1 \u2264 |s| \u2264 10 5 1 \u2264 K \u2264 10 9 class Solution : def kPeriodic ( self , s , k ): freq = [ 0 ] * 26 different_chars = 0 current_char = '' for char in s : freq [ ord ( char ) - ord ( 'a' )] += 1 if ( freq [ ord ( char ) - ord ( 'a' )] == 1 ): different_chars += 1 current_char = 'a' size , index = 0 , 0 result = [ '-' ] * len ( s ) while ( result [ index ] == '-' ): size += 1 result [ index ] = '.' index += k index %= len ( s ) for i in range ( 26 ): if ( freq [ i ] % size != 0 ): return \"\" result = [ '-' ] * len ( s ) cnt , index , charindex = 0 , 0 , 0 while ( cnt < len ( s )): while ( result [ index ] != '-' ): index += 1 while ( freq [ charindex ] == 0 ): charindex += 1 while ( result [ index ] == '-' ): cnt += 1 result [ index ] = chr ( ord ( 'a' ) + charindex ) index += k index %= len ( s ) freq [ charindex ] -= size return '' . join ( result )","title":"K-periodic Circular String"},{"location":"GFG-Contests/weekly-contest-103/Refueling.html","tags":["Math","Contest"],"text":"Problem Statement You're driving a car on the x-axis. But you ran out of fuel exactly at point X . Luckily, there are refueling stations. For any non-negative integer K , there is a refueling station at point 2 K . Find the position of your nearest refueling station. If there is more than 1 possible station, return the one present on the right. Solve Example 1: Input: X = 3, Output: 4 Explanation: Nearest station from X = 3 is 2 and 1. Since 4 is present in the rightmost position therefore 4 is the answer. Example 2: Input: X = 2, Output: 2 Explanation: Nearest station from X = 2 is 2. Your Task: The task is to complete the function refueling() which takes an integer X as input parameters and returns the position of the nearest refueling station Constraints: 1 \u2264 X \u2264 10 9 class Solution : def refueling ( self , position ): last = 1 curr = 1 while ( curr < position ): last = curr curr *= 2 return curr if ( abs ( curr - position ) <= abs ( last - position )) else last","title":"Refueling"},{"location":"GFG-Contests/weekly-contest-103/Refueling.html#problem-statement","text":"You're driving a car on the x-axis. But you ran out of fuel exactly at point X . Luckily, there are refueling stations. For any non-negative integer K , there is a refueling station at point 2 K . Find the position of your nearest refueling station. If there is more than 1 possible station, return the one present on the right. Solve Example 1: Input: X = 3, Output: 4 Explanation: Nearest station from X = 3 is 2 and 1. Since 4 is present in the rightmost position therefore 4 is the answer. Example 2: Input: X = 2, Output: 2 Explanation: Nearest station from X = 2 is 2. Your Task: The task is to complete the function refueling() which takes an integer X as input parameters and returns the position of the nearest refueling station Constraints: 1 \u2264 X \u2264 10 9 class Solution : def refueling ( self , position ): last = 1 curr = 1 while ( curr < position ): last = curr curr *= 2 return curr if ( abs ( curr - position ) <= abs ( last - position )) else last","title":"Problem Statement"},{"location":"Graphs/index.html","text":"Graphs This pages act as home page for Graph concepts Topics","title":"Home"},{"location":"Graphs/index.html#graphs","text":"This pages act as home page for Graph concepts","title":"Graphs"},{"location":"Graphs/index.html#topics","text":"","title":"Topics"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html","text":"Introduction It's a greedy Shortest Path Algorithm Helps to find shortest path from source to all vertices Applications Network Routing Protocols Transportation Planning Computer Networks Limitations It doesn't work for Negative weight cycles . Video Youtube Techdose Algorithm Maintain a SET of Processed Nodes Assign all Nodes with distance Value = Infinity Loop: (Until all vertices are Included) Pick min value vertex which is not already processed. Include this selected Node in Processed Set Update all the adjacent Node distances Pick min value vertex which is not already processed. If (New distance < old distance) then Update Else Skip Dijkstra's Algorithm Time Complexity O(V^2) Simple Implementation using Adj Matrix O(ElogV) (Adj List + min heap) Implementation (ElogV) Java Adj List, PriorityQueue Adj List, TreeSet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { static int [] dijkstra ( int n , ArrayList < ArrayList < ArrayList < Integer >>> adj , int s ) { int [] distances = new int [ n ] ; Arrays . fill ( distances , Integer . MAX_VALUE ); distances [ s ] = 0 ; Set < Integer > processed = new HashSet < Integer > (); Queue < Integer []> queue = new PriorityQueue <> ( new Comparator < Integer []> (){ public int compare ( Integer [] a , Integer [] b ){ return Integer . compare ( a [ 1 ] , b [ 1 ] ); } }); queue . add ( new Integer [] { s , 0 }); while ( processed . size () < n - 1 && queue . size () > 0 ){ Integer [] vertex = queue . poll (); processed . add ( vertex [ 0 ] ); for ( var v : adj . get ( vertex [ 0 ] )){ if ( processed . contains ( v . get ( 0 ))){ continue ; } if ( distances [ v . get ( 0 ) ] > distances [ vertex [ 0 ]] + v . get ( 1 )){ distances [ v . get ( 0 ) ] = distances [ vertex [ 0 ]] + v . get ( 1 ); queue . add ( new Integer [] { v . get ( 0 ), distances [ v . get ( 0 ) ] }); } } } return distances ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Node { int index ; int dist ; Node ( int index , int dist ){ this . index = index ; this . dist = dist ; } } class Solution { //Function to find the shortest distance of all the vertices //from the source vertex S. static int [] dijkstra ( int v , ArrayList < ArrayList < ArrayList < Integer >>> adj , int s ) { int result [] = new int [ v ] ; Node [] o = new Node [ v ] ; TreeSet < Node > queue = new TreeSet < Node > ( new Comparator < Node > (){ public int compare ( Node n1 , Node n2 ){ if ( n1 . dist == n2 . dist ){ return Integer . compare ( n1 . index , n2 . index ); } return Integer . compare ( n1 . dist , n2 . dist ); } }); for ( int i = 0 ; i < v ; i ++ ){ result [ i ] = Integer . MAX_VALUE ; int dist = Integer . MAX_VALUE ; if ( i == s ){ dist = 0 ; } o [ i ] = new Node ( i , dist ); } queue . add ( o [ s ] ); while ( ! queue . isEmpty ()){ var node = queue . pollFirst (); result [ node . index ] = node . dist ; for ( var u : adj . get ( node . index )){ if ( result [ u . get ( 0 ) ] > node . dist + u . get ( 1 )){ o [ u . get ( 0 ) ] . dist = node . dist + u . get ( 1 ); result [ u . get ( 0 ) ] = node . dist + u . get ( 1 ); queue . add ( o [ u . get ( 0 ) ] ); } } } return result ; } } Python Using Heapq 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import heapq class Solution : def dijkstra ( self , v , adj , s ): distances = [ float ( \"Inf\" )] * ( v ) distances [ s ] = 0 queue = [] heapq . heappush ( queue , ( 0 , s )) processed = set () while ( queue and len ( processed ) < v - 1 ): dist , vertex = heapq . heappop ( queue ) processed . add ( vertex ) for child , distance in adj [ vertex ]: if ( child in processed ): continue ; if ( distances [ child ] > distance + dist ): distances [ child ] = distance + dist heapq . heappush ( queue , ( distances [ child ], child )) return distances Practice Problems Airlines and Railways","title":"Dijkstra's Algorithm"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#introduction","text":"It's a greedy Shortest Path Algorithm Helps to find shortest path from source to all vertices","title":"Introduction"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#applications","text":"Network Routing Protocols Transportation Planning Computer Networks","title":"Applications"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#limitations","text":"It doesn't work for Negative weight cycles .","title":"Limitations"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#video","text":"Youtube Techdose","title":"Video"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#algorithm","text":"Maintain a SET of Processed Nodes Assign all Nodes with distance Value = Infinity Loop: (Until all vertices are Included) Pick min value vertex which is not already processed. Include this selected Node in Processed Set Update all the adjacent Node distances Pick min value vertex which is not already processed. If (New distance < old distance) then Update Else Skip Dijkstra's Algorithm","title":"Algorithm"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#time-complexity","text":"O(V^2) Simple Implementation using Adj Matrix O(ElogV) (Adj List + min heap)","title":"Time Complexity"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#implementation-elogv","text":"","title":"Implementation (ElogV)"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#java","text":"Adj List, PriorityQueue Adj List, TreeSet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { static int [] dijkstra ( int n , ArrayList < ArrayList < ArrayList < Integer >>> adj , int s ) { int [] distances = new int [ n ] ; Arrays . fill ( distances , Integer . MAX_VALUE ); distances [ s ] = 0 ; Set < Integer > processed = new HashSet < Integer > (); Queue < Integer []> queue = new PriorityQueue <> ( new Comparator < Integer []> (){ public int compare ( Integer [] a , Integer [] b ){ return Integer . compare ( a [ 1 ] , b [ 1 ] ); } }); queue . add ( new Integer [] { s , 0 }); while ( processed . size () < n - 1 && queue . size () > 0 ){ Integer [] vertex = queue . poll (); processed . add ( vertex [ 0 ] ); for ( var v : adj . get ( vertex [ 0 ] )){ if ( processed . contains ( v . get ( 0 ))){ continue ; } if ( distances [ v . get ( 0 ) ] > distances [ vertex [ 0 ]] + v . get ( 1 )){ distances [ v . get ( 0 ) ] = distances [ vertex [ 0 ]] + v . get ( 1 ); queue . add ( new Integer [] { v . get ( 0 ), distances [ v . get ( 0 ) ] }); } } } return distances ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Node { int index ; int dist ; Node ( int index , int dist ){ this . index = index ; this . dist = dist ; } } class Solution { //Function to find the shortest distance of all the vertices //from the source vertex S. static int [] dijkstra ( int v , ArrayList < ArrayList < ArrayList < Integer >>> adj , int s ) { int result [] = new int [ v ] ; Node [] o = new Node [ v ] ; TreeSet < Node > queue = new TreeSet < Node > ( new Comparator < Node > (){ public int compare ( Node n1 , Node n2 ){ if ( n1 . dist == n2 . dist ){ return Integer . compare ( n1 . index , n2 . index ); } return Integer . compare ( n1 . dist , n2 . dist ); } }); for ( int i = 0 ; i < v ; i ++ ){ result [ i ] = Integer . MAX_VALUE ; int dist = Integer . MAX_VALUE ; if ( i == s ){ dist = 0 ; } o [ i ] = new Node ( i , dist ); } queue . add ( o [ s ] ); while ( ! queue . isEmpty ()){ var node = queue . pollFirst (); result [ node . index ] = node . dist ; for ( var u : adj . get ( node . index )){ if ( result [ u . get ( 0 ) ] > node . dist + u . get ( 1 )){ o [ u . get ( 0 ) ] . dist = node . dist + u . get ( 1 ); result [ u . get ( 0 ) ] = node . dist + u . get ( 1 ); queue . add ( o [ u . get ( 0 ) ] ); } } } return result ; } }","title":"Java"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#python","text":"Using Heapq 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import heapq class Solution : def dijkstra ( self , v , adj , s ): distances = [ float ( \"Inf\" )] * ( v ) distances [ s ] = 0 queue = [] heapq . heappush ( queue , ( 0 , s )) processed = set () while ( queue and len ( processed ) < v - 1 ): dist , vertex = heapq . heappop ( queue ) processed . add ( vertex ) for child , distance in adj [ vertex ]: if ( child in processed ): continue ; if ( distances [ child ] > distance + dist ): distances [ child ] = distance + dist heapq . heappush ( queue , ( distances [ child ], child )) return distances","title":"Python"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#practice-problems","text":"Airlines and Railways","title":"Practice Problems"},{"location":"MyProgress/index.html","text":"Profiles GeeksForGeeks Leetcode Codeforces Hackerrank Current Month Problems Solved Month Wise Problems Solved Topic Wise Problems Solved Problems Solved Per Platform Problems Solved per difficulty in Leetcode","title":"Progress Tracking"},{"location":"MyProgress/index.html#profiles","text":"GeeksForGeeks Leetcode Codeforces Hackerrank","title":"Profiles"},{"location":"MyProgress/index.html#current-month-problems-solved","text":"","title":"Current Month Problems Solved"},{"location":"MyProgress/index.html#month-wise-problems-solved","text":"","title":"Month Wise Problems Solved"},{"location":"MyProgress/index.html#topic-wise-problems-solved","text":"","title":"Topic Wise Problems Solved"},{"location":"MyProgress/index.html#problems-solved-per-platform","text":"","title":"Problems Solved Per Platform"},{"location":"MyProgress/index.html#problems-solved-per-difficulty-in-leetcode","text":"","title":"Problems Solved per difficulty in Leetcode"},{"location":"MyProgress/Contests.html","text":"GFG Weekly Coding Contest GFG Weekly Contest 102 - 14th May 2023 Solved 2 Problems 1st is simple sort and difference 2nd is tree based finding sum of cousin nodes 3rd problem seemed to be Graph based and shortest path, don't remember algorithms Contest Link","title":"Contests"},{"location":"MyProgress/Contests.html#gfg-weekly-coding-contest","text":"GFG Weekly Contest 102 - 14th May 2023 Solved 2 Problems 1st is simple sort and difference 2nd is tree based finding sum of cousin nodes 3rd problem seemed to be Graph based and shortest path, don't remember algorithms Contest Link","title":"GFG Weekly Coding Contest"},{"location":"MyProgress/May-logs.html","text":"Daily Updates 14/05/2023 Created a site to track Progress. Solved 2 problems in codeforces. Solved JS 30days challenge problem in leetcode Participated in GFG Contest and was able to solve 2 problems. 22/05/2023 Solved a problem on Spoj (topic - Dp on Trees) Spent 1 hour on udemy DP course Solved problems of GFG Weekly Contest 103 Solved 1 problem on Leetcode - Dp on Trees","title":"May logs"},{"location":"MyProgress/May-logs.html#daily-updates","text":"14/05/2023 Created a site to track Progress. Solved 2 problems in codeforces. Solved JS 30days challenge problem in leetcode Participated in GFG Contest and was able to solve 2 problems. 22/05/2023 Solved a problem on Spoj (topic - Dp on Trees) Spent 1 hour on udemy DP course Solved problems of GFG Weekly Contest 103 Solved 1 problem on Leetcode - Dp on Trees","title":"Daily Updates"},{"location":"PremiumAlgo100/index.html","tags":["Leetcode","Premium","Staff Picked"],"text":"Introduction Contains 100 Premium questions that are picked by leetcode staff covering various topics. Problems Arrays/String Maximum Distance in Array Binary Search Tree Largest BST SubTree )","title":"Index"},{"location":"PremiumAlgo100/index.html#introduction","text":"Contains 100 Premium questions that are picked by leetcode staff covering various topics.","title":"Introduction"},{"location":"PremiumAlgo100/index.html#problems","text":"","title":"Problems"},{"location":"PremiumAlgo100/index.html#arraysstring","text":"Maximum Distance in Array","title":"Arrays/String"},{"location":"PremiumAlgo100/index.html#binary-search-tree","text":"Largest BST SubTree )","title":"Binary Search Tree"},{"location":"PremiumAlgo100/max-distance-in-arrays.html","tags":["Leetcode","Arrays","Greedy","Premium"],"text":"You are given m arrays , where each array is sorted in ascending order . You can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers a and b to be their absolute difference |a - b| . Return the maximum distance . Example 1: Input: arrays = [[1,2,3],[4,5],[1,2,3]] Output: 4 Explanation: One way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array. Example 2: Input: arrays = [[1],[1]] Output: 0 Constraints: m == arrays.length 2 <= m <= 10<sup>5</sup> 1 <= arrays[i].length <= 500 -10<sup>4</sup> <= arrays[i][j] <= 10<sup>4</sup> arrays[i] is sorted in ascending order . There will be at most 10<sup>5</sup> integers in all the arrays. class Solution : def maxDistance ( self , arrays : List [ List [ int ]]) -> int : max_distance = 0 arrays . sort ( key = lambda x : x [ 0 ]) for i in range ( 1 , len ( arrays )): max_distance = max ( max_distance , arrays [ i ][ - 1 ] - arrays [ 0 ][ 0 ]) if ( len ( arrays ) > 1 ): max_distance = max ( max_distance , arrays [ 0 ][ - 1 ] - arrays [ 1 ][ 0 ]) return max_distance","title":"Maximum Distance in Arrays"},{"location":"SystemDesign/relationships.html","tags":["Design Principles","System Design","Basics"],"text":"Introduction There are two types of relationships Is-a relationship(inheritance) Has-a relationship Is-a Relationship The \"is-a\" relationship is a fundamental concept in object-oriented programming that represents inheritance or specialization between classes. It signifies that a subclass is a specific type of its superclass. The \"is-a\" relationship can be understood as a relationship of classification or categorization. In an \"is-a\" relationship, the subclass inherits the properties, methods, and behavior of the superclass. It means that objects of the subclass can be treated as objects of the superclass, and they can be used in any context where the superclass is expected. This concept is also known as subtype polymorphism. Has-a Relationship In object-oriented programming, the \"has-a\" relationship represents a composition or aggregation between classes, indicating that one class has another class as a part or component. There are several types of \"has-a\" relationships that can exist between classes. Here are some common types: Composition: Composition represents a strong \"has-a\" relationship where one class is composed of one or more objects of another class. The lifetime of the composed objects is tightly coupled with the lifetime of the parent object. If the parent object is destroyed, the composed objects are also destroyed. The composed objects cannot exist independently outside of the parent object. /** * A \"has-a relationship\" represents composition or aggregation, * where one class contains an instance of another class as a member variable. * It signifies that an object has another object as a part of its composition * or as a member of its collection. */ public class Car { /** * the Car class has a member variable engine of type Engine. * It represents a composition relationship, * where a car has an engine as one of its components. * The Car class contains an instance of the Engine class, * and it can utilize the engine's properties and behaviors. */ private Engine engine ; // Other car properties and behaviors public Car () { engine = new Engine (); } } Aggregation: Aggregation is a type of \"has-a\" relationship where one class has a reference to another class, but the referenced object can exist independently and have a longer lifetime than the parent object. In aggregation, the child objects are not tightly bound to the parent object's lifecycle. The child objects can be shared by multiple parent objects or exist even when the parent object is destroyed. /** * Aggregation represents a \"has-a relationship\" * where one class contains or holds a reference to another class * as a part of its structure. * The aggregated object can exist independently outside the scope of the containing object. */ public class Book { private String title ; private String author ; public Book ( String title , String author ) { this . title = title ; this . author = author ; } // Book properties and behaviors } /** * The Library class has a list of Book objects as a member variable. * The Library class aggregates Book objects, and a Book can exist independently, * even if the Library no longer exists. * The Library class doesn't control the lifespan or ownership of the Book objects. */ public class Library { private List < Book > books ; public Library () { books = new ArrayList <> (); } public void addBook ( Book book ) { books . add ( book ); } } Association: Association is a looser form of the \"has-a\" relationship where one class is associated with another class, but they may not have a strong containment or ownership relationship. The associated objects can exist independently and have their own lifecycles. Associations can be bi-directional or uni-directional, and they can have multiplicity (one-to-one, one-to-many, many-to-many) indicating the cardinality of the relationship. /** * The Enrollment class represents the association between a Student and a Course. * An enrollment connects a student to a course, * but the Student and Course objects can exist independently. * The Enrollment class holds references to both the Student and Course objects * and manages the relationship between them. */ public class Enrollment { private Student student ; private Course course ; // Enrollment properties and behaviors public Enrollment ( Student student , Course course ) { this . student = student ; this . course = course ; } } Dependency: Dependency represents a weaker form of the \"has-a\" relationship, indicating that one class depends on another class for some functionality, but there is no containment or ownership involved. The dependent class uses the services or functionality provided by the other class, but there is no direct reference or direct object relationship between them. It's important to choose the appropriate type of \"has-a\" relationship based on the specific requirements and nature of the classes involved. By properly defining and managing these relationships, we can establish the desired object structure and behavior in an object-oriented system.","title":"Relationships"},{"location":"SystemDesign/relationships.html#introduction","text":"There are two types of relationships Is-a relationship(inheritance) Has-a relationship","title":"Introduction"},{"location":"SystemDesign/relationships.html#is-a-relationship","text":"The \"is-a\" relationship is a fundamental concept in object-oriented programming that represents inheritance or specialization between classes. It signifies that a subclass is a specific type of its superclass. The \"is-a\" relationship can be understood as a relationship of classification or categorization. In an \"is-a\" relationship, the subclass inherits the properties, methods, and behavior of the superclass. It means that objects of the subclass can be treated as objects of the superclass, and they can be used in any context where the superclass is expected. This concept is also known as subtype polymorphism.","title":"Is-a Relationship"},{"location":"SystemDesign/relationships.html#has-a-relationship","text":"In object-oriented programming, the \"has-a\" relationship represents a composition or aggregation between classes, indicating that one class has another class as a part or component. There are several types of \"has-a\" relationships that can exist between classes. Here are some common types: Composition: Composition represents a strong \"has-a\" relationship where one class is composed of one or more objects of another class. The lifetime of the composed objects is tightly coupled with the lifetime of the parent object. If the parent object is destroyed, the composed objects are also destroyed. The composed objects cannot exist independently outside of the parent object. /** * A \"has-a relationship\" represents composition or aggregation, * where one class contains an instance of another class as a member variable. * It signifies that an object has another object as a part of its composition * or as a member of its collection. */ public class Car { /** * the Car class has a member variable engine of type Engine. * It represents a composition relationship, * where a car has an engine as one of its components. * The Car class contains an instance of the Engine class, * and it can utilize the engine's properties and behaviors. */ private Engine engine ; // Other car properties and behaviors public Car () { engine = new Engine (); } } Aggregation: Aggregation is a type of \"has-a\" relationship where one class has a reference to another class, but the referenced object can exist independently and have a longer lifetime than the parent object. In aggregation, the child objects are not tightly bound to the parent object's lifecycle. The child objects can be shared by multiple parent objects or exist even when the parent object is destroyed. /** * Aggregation represents a \"has-a relationship\" * where one class contains or holds a reference to another class * as a part of its structure. * The aggregated object can exist independently outside the scope of the containing object. */ public class Book { private String title ; private String author ; public Book ( String title , String author ) { this . title = title ; this . author = author ; } // Book properties and behaviors } /** * The Library class has a list of Book objects as a member variable. * The Library class aggregates Book objects, and a Book can exist independently, * even if the Library no longer exists. * The Library class doesn't control the lifespan or ownership of the Book objects. */ public class Library { private List < Book > books ; public Library () { books = new ArrayList <> (); } public void addBook ( Book book ) { books . add ( book ); } } Association: Association is a looser form of the \"has-a\" relationship where one class is associated with another class, but they may not have a strong containment or ownership relationship. The associated objects can exist independently and have their own lifecycles. Associations can be bi-directional or uni-directional, and they can have multiplicity (one-to-one, one-to-many, many-to-many) indicating the cardinality of the relationship. /** * The Enrollment class represents the association between a Student and a Course. * An enrollment connects a student to a course, * but the Student and Course objects can exist independently. * The Enrollment class holds references to both the Student and Course objects * and manages the relationship between them. */ public class Enrollment { private Student student ; private Course course ; // Enrollment properties and behaviors public Enrollment ( Student student , Course course ) { this . student = student ; this . course = course ; } } Dependency: Dependency represents a weaker form of the \"has-a\" relationship, indicating that one class depends on another class for some functionality, but there is no containment or ownership involved. The dependent class uses the services or functionality provided by the other class, but there is no direct reference or direct object relationship between them. It's important to choose the appropriate type of \"has-a\" relationship based on the specific requirements and nature of the classes involved. By properly defining and managing these relationships, we can establish the desired object structure and behavior in an object-oriented system.","title":"Has-a Relationship"},{"location":"SystemDesign/DesignPatterns/Java/SingletonPattern.html","tags":["Design Patterns","Creational"],"text":"Introduction Deals with object creation mechanism. It is used when we want to have only one object of a particular class. An application may require multiple object instances that all use one unique resource. This fact introduces instability because any of these objects can access such a resource. A singleton guarantees only one instance that provides a global access point to all clients within the desired scope of the running JVM. Real Time Usage in JDK The best example of using a singleton is a running Java application, or more precisely, the runtime. It is found in the Runtime class and its method, getRuntime , resides in the java.lang package of the java.base module. The method returns an object associated with the current Java application. The runtime instance allows the client to add, for example, shutdown hooks to the running application. Implementation Make the constructor private - helps in restricting object creation outside of the class. -","title":"Singleton Design Pattern"},{"location":"SystemDesign/DesignPatterns/Java/SingletonPattern.html#introduction","text":"Deals with object creation mechanism. It is used when we want to have only one object of a particular class. An application may require multiple object instances that all use one unique resource. This fact introduces instability because any of these objects can access such a resource. A singleton guarantees only one instance that provides a global access point to all clients within the desired scope of the running JVM.","title":"Introduction"},{"location":"SystemDesign/DesignPatterns/Java/SingletonPattern.html#real-time-usage-in-jdk","text":"The best example of using a singleton is a running Java application, or more precisely, the runtime. It is found in the Runtime class and its method, getRuntime , resides in the java.lang package of the java.base module. The method returns an object associated with the current Java application. The runtime instance allows the client to add, for example, shutdown hooks to the running application.","title":"Real Time Usage in JDK"},{"location":"SystemDesign/DesignPatterns/Java/SingletonPattern.html#implementation","text":"Make the constructor private - helps in restricting object creation outside of the class. -","title":"Implementation"},{"location":"SystemDesign/DesignPatterns/TypeScript/Creational-Design-Patterns/index.html","tags":["Design Patterns","Intro"],"text":"There are two distinct phases Creating an object of a specific type or for a specific purpose : You want to create an object sometime when the application runs but you want to maintain a consistent and easy-to-use way of creating instances of these objects. Every so often you want to control what parameters to use, what category of objects to create, or how to reuse some functionality and clone objects based on existing ones. Managing the object life cycle : You want to control how many instances of the object exist and where they are stored. You also want to be able to safely destroy those instances when they are no longer required. There are 7 patterns: Singleton Pattern Factory Pattern Factory Pattern method. Abstract Factory Method. Builder Pattern Prototype Pattern Object Pool Pattern","title":"Introduction"},{"location":"SystemDesign/DesignPatterns/TypeScript/Creational-Design-Patterns/SingletonPattern.html","tags":["Design Patterns","Creational"],"text":"Introduction The term Singleton describes something that has only a single presence in the program. You may want to keep only one instance of a particular class simply because it is either expensive to create or it does not make sense to keep more than one for the lifetime of the program. Observations Global Access Point : When you have a singleton, you essentially have one and only one access point of its instance. That's why a lot of times you find that the Singleton is just another name for global instance. The instance is cached somewhere : You cache the instance of the Singleton object somewhere so that you can retrieve it on demand. Typically, you store it within the class instance itself as a static variable, but it can be stored inside inversion of control container The instance is created on demand : The instance is not created the moment it is declared. Instead, it is created lazily, in a FIFO fashion. This has the benefit of avoiding expensive initializations when starting applications. Unique instance per class : The instance is unique per class in the sense that different classes have their own singletons When do we use Singleton Patterns ? The Singleton is used to control access to external resources such as database connections, API endpoints, or filesystems. This means you don't want to have two or more objects holding references to those resources without some sort of coordination. Failure to avoid that can lead to having race conditions, increased resource utilization, and integrity issues. UML Class Diagram The class the is said to be singleton when it contains at least the following signature: Private variable - instance and public method - getInstance() Implementation Classic Implementation Step: 1 - Private Constructor(goal: Prevent the manual creation of singleton objects) export class Singleton { // Prevents creation of new instances private constructor () {} } Step: 2 - Cached Instance(goal: ensure only one instance per class) export class Singleton { // Stores the singleton instance private static instance : Singleton ; // Prevents creation of new instances private constructor () {} } Step: 3 Single Access(goal: to access cached instance) export class Singleton { // Stores the singleton instance private static instance : Singleton ; // Prevents creation of new instances private constructor () {} // Method to retrieve instance static getInstance () { if ( ! Singleton . instance ) { Singleton . instance = new Singleton (); } return Singleton . instance ; } } Note: We created the instance lazily, and when the class is discovered at the the runtime. This is to ensure you avoid any side effects of the instantiation process, such as increased memory usage or calling external services. If this is not strictly required, you may want to eagerly create the instance from the start. Example export class UsersAPISingleton { private static instance : UsersAPISingleton ; private constructor () {} static getInstance () { if ( ! UsersAPISingleton . instance ) { UsersAPISingleton . instance = new UsersAPISingleton (); } return UsersAPISingleton . instance ; } getUsers () : Promise < any > { return Promise . resolve ([ 'Alex' , 'John' , 'Sarah' ]); } } const usersPromise = UsersAPISingleton . getInstance (). getUsers (); usersPromise . then (( res ) => { console . log ( res ); }); Modern Implementation Using Module Resolution Singltons Instead of creating your own Singleton implementation and having the class caching this instance, you can leverage the module system loading mechanism. Step: 1 - Create a class class ApiServiceSingleton {} Step: 2 - export default instance variable export default new ApiServiceSingleton (); Note: With this appraoch we are delegating the control of the singleton to the module system Node Js Module System This module system caches the modules based on the absolute required path of this module. example /users/sumanth/projects/typescript-4-design-patterns/chapters/chapter-3/ModuleSingleton.ts As long as we import this file and it resolves to the same absolute path, then the module system will use the same cached instance Using an Ioc Container Using an IoC container is the next alternative way to control Singleton. import 'reflect-metadata' ; import { injectable , Container } from 'inversify' ; interface UsersApiService { getUsers () : Promise < string [] > ; } let TYPES = { UsersApiService : Symbol ( 'UsersApiService' ), }; @injectable () class UsersApiServiceImpl implements UsersApiService { getUsers () : Promise < string [] > { return Promise . resolve ([ 'Alex' , 'John' , 'Sarah' ]); } } const container = new Container (); container . bind < UsersApiService > ( TYPES . UsersApiService ) . to ( UsersApiServiceImpl ) . inSingletonScope (); container . get < UsersApiService > ( TYPES . UsersApiService ) . getUsers () . then (( res ) => console . log ( res )); Criticisms Global Instance Pollution: They are problematic to test or to mock, and using global variables means ignoring any flexibility you can get from interfaces or other abstractions. Hard to get right : The singleton is hard to implement, especially if you plan for testability and lazy initialization, and want to use it as a global variable.","title":"Singleton Design Pattern"},{"location":"SystemDesign/DesignPatterns/TypeScript/Creational-Design-Patterns/SingletonPattern.html#introduction","text":"The term Singleton describes something that has only a single presence in the program. You may want to keep only one instance of a particular class simply because it is either expensive to create or it does not make sense to keep more than one for the lifetime of the program. Observations Global Access Point : When you have a singleton, you essentially have one and only one access point of its instance. That's why a lot of times you find that the Singleton is just another name for global instance. The instance is cached somewhere : You cache the instance of the Singleton object somewhere so that you can retrieve it on demand. Typically, you store it within the class instance itself as a static variable, but it can be stored inside inversion of control container The instance is created on demand : The instance is not created the moment it is declared. Instead, it is created lazily, in a FIFO fashion. This has the benefit of avoiding expensive initializations when starting applications. Unique instance per class : The instance is unique per class in the sense that different classes have their own singletons","title":"Introduction"},{"location":"SystemDesign/DesignPatterns/TypeScript/Creational-Design-Patterns/SingletonPattern.html#when-do-we-use-singleton-patterns","text":"The Singleton is used to control access to external resources such as database connections, API endpoints, or filesystems. This means you don't want to have two or more objects holding references to those resources without some sort of coordination. Failure to avoid that can lead to having race conditions, increased resource utilization, and integrity issues.","title":"When do we use Singleton Patterns ?"},{"location":"SystemDesign/DesignPatterns/TypeScript/Creational-Design-Patterns/SingletonPattern.html#uml-class-diagram","text":"The class the is said to be singleton when it contains at least the following signature: Private variable - instance and public method - getInstance()","title":"UML Class Diagram"},{"location":"SystemDesign/DesignPatterns/TypeScript/Creational-Design-Patterns/SingletonPattern.html#implementation","text":"","title":"Implementation"},{"location":"SystemDesign/DesignPatterns/TypeScript/Creational-Design-Patterns/SingletonPattern.html#classic-implementation","text":"Step: 1 - Private Constructor(goal: Prevent the manual creation of singleton objects) export class Singleton { // Prevents creation of new instances private constructor () {} } Step: 2 - Cached Instance(goal: ensure only one instance per class) export class Singleton { // Stores the singleton instance private static instance : Singleton ; // Prevents creation of new instances private constructor () {} } Step: 3 Single Access(goal: to access cached instance) export class Singleton { // Stores the singleton instance private static instance : Singleton ; // Prevents creation of new instances private constructor () {} // Method to retrieve instance static getInstance () { if ( ! Singleton . instance ) { Singleton . instance = new Singleton (); } return Singleton . instance ; } } Note: We created the instance lazily, and when the class is discovered at the the runtime. This is to ensure you avoid any side effects of the instantiation process, such as increased memory usage or calling external services. If this is not strictly required, you may want to eagerly create the instance from the start.","title":"Classic Implementation"},{"location":"SystemDesign/DesignPatterns/TypeScript/Creational-Design-Patterns/SingletonPattern.html#example","text":"export class UsersAPISingleton { private static instance : UsersAPISingleton ; private constructor () {} static getInstance () { if ( ! UsersAPISingleton . instance ) { UsersAPISingleton . instance = new UsersAPISingleton (); } return UsersAPISingleton . instance ; } getUsers () : Promise < any > { return Promise . resolve ([ 'Alex' , 'John' , 'Sarah' ]); } } const usersPromise = UsersAPISingleton . getInstance (). getUsers (); usersPromise . then (( res ) => { console . log ( res ); });","title":"Example"},{"location":"SystemDesign/DesignPatterns/TypeScript/Creational-Design-Patterns/SingletonPattern.html#modern-implementation","text":"","title":"Modern Implementation"},{"location":"SystemDesign/DesignPatterns/TypeScript/Creational-Design-Patterns/SingletonPattern.html#using-module-resolution-singltons","text":"Instead of creating your own Singleton implementation and having the class caching this instance, you can leverage the module system loading mechanism. Step: 1 - Create a class class ApiServiceSingleton {} Step: 2 - export default instance variable export default new ApiServiceSingleton (); Note: With this appraoch we are delegating the control of the singleton to the module system Node Js Module System This module system caches the modules based on the absolute required path of this module. example /users/sumanth/projects/typescript-4-design-patterns/chapters/chapter-3/ModuleSingleton.ts As long as we import this file and it resolves to the same absolute path, then the module system will use the same cached instance","title":"Using Module Resolution Singltons"},{"location":"SystemDesign/DesignPatterns/TypeScript/Creational-Design-Patterns/SingletonPattern.html#using-an-ioc-container","text":"Using an IoC container is the next alternative way to control Singleton. import 'reflect-metadata' ; import { injectable , Container } from 'inversify' ; interface UsersApiService { getUsers () : Promise < string [] > ; } let TYPES = { UsersApiService : Symbol ( 'UsersApiService' ), }; @injectable () class UsersApiServiceImpl implements UsersApiService { getUsers () : Promise < string [] > { return Promise . resolve ([ 'Alex' , 'John' , 'Sarah' ]); } } const container = new Container (); container . bind < UsersApiService > ( TYPES . UsersApiService ) . to ( UsersApiServiceImpl ) . inSingletonScope (); container . get < UsersApiService > ( TYPES . UsersApiService ) . getUsers () . then (( res ) => console . log ( res ));","title":"Using an Ioc Container"},{"location":"SystemDesign/DesignPatterns/TypeScript/Creational-Design-Patterns/SingletonPattern.html#criticisms","text":"Global Instance Pollution: They are problematic to test or to mock, and using global variables means ignoring any flexibility you can get from interfaces or other abstractions. Hard to get right : The singleton is hard to implement, especially if you plan for testability and lazy initialization, and want to use it as a global variable.","title":"Criticisms"},{"location":"SystemDesign/Fundamentals/hashing.html","tags":["System Design","Basics","Hash"],"text":"","title":"Hashing"},{"location":"SystemDesign/SolidPrinciples/dependency-inversion.html","tags":["Design Principles","System Design","Basics","SOLID"],"text":"Introduction The Dependency Inversion Principle states that high-level modules should not depend on low-level modules. Both should depend on abstractions. This principle emphasizes the importance of designing modules and components in a way that they depend on abstractions or interfaces rather than concrete implementations. By doing so, the system becomes more flexible, maintainable, and easily testable. Example The PaymentService example demonstrates the usage of Dependency Inversion Principle (DIP) and Inversion of Control (IoC) in designing a payment service. First, we define an abstraction called PaymentGateway using an interface. This abstraction represents the operations related to processing payments. It includes a method processPayment that takes a payment token and an amount, and returns a boolean indicating whether the payment was successful. public interface PaymentGateway { boolean processPayment ( String paymentToken , double amount ); } The PaymentService class represents the high-level module that provides payment functionality. It depends on the PaymentGateway abstraction rather than a specific implementation. This dependency is injected through the constructor, following the principle of Dependency Inversion. The PaymentService class has a method called makePayment that takes a payment token and an amount. Inside this method, the payment logic is performed, and the PaymentGateway abstraction is used to process the payment by calling the processPayment method. public class PaymentService { private PaymentGateway paymentGateway ; public PaymentService ( PaymentGateway paymentGateway ){ this . paymentGateway = paymentGateway ; } public boolean makePayment ( String paymentToken , double amount ){ return paymentGateway . processPayment ( paymentToken , amount ); } } To demonstrate the flexibility provided by DIP and IoC, we provide an implementation of the PaymentGateway interface called PayPalGateway . This class includes the specific logic to process payments using the PayPal API. public class PayPalGateway implements PaymentGateway { @Override public boolean processPayment ( String paymentToken , double amount ) { return true ; } } By following DIP and IoC, the PaymentService is decoupled from the specific implementation of the payment gateway. This allows us to easily swap the payment gateway implementation by providing a different implementation of the PaymentGateway interface, such as a StripeGateway class that processes payments using the Stripe API. public class StripeGateway implements PaymentGateway { public boolean processPayment ( String paymentToken , double amount ) { // Implementation specific to Stripe payment gateway // Process the payment using the Stripe API return true ; // Payment successful } } Overall, this design promotes modularity, flexibility, and maintainability in the payment service, enabling easy integration of different payment gateways without modifying the core logic of the PaymentService class.","title":"Dependency Inversion Principle"},{"location":"SystemDesign/SolidPrinciples/dependency-inversion.html#introduction","text":"The Dependency Inversion Principle states that high-level modules should not depend on low-level modules. Both should depend on abstractions. This principle emphasizes the importance of designing modules and components in a way that they depend on abstractions or interfaces rather than concrete implementations. By doing so, the system becomes more flexible, maintainable, and easily testable.","title":"Introduction"},{"location":"SystemDesign/SolidPrinciples/dependency-inversion.html#example","text":"The PaymentService example demonstrates the usage of Dependency Inversion Principle (DIP) and Inversion of Control (IoC) in designing a payment service. First, we define an abstraction called PaymentGateway using an interface. This abstraction represents the operations related to processing payments. It includes a method processPayment that takes a payment token and an amount, and returns a boolean indicating whether the payment was successful. public interface PaymentGateway { boolean processPayment ( String paymentToken , double amount ); } The PaymentService class represents the high-level module that provides payment functionality. It depends on the PaymentGateway abstraction rather than a specific implementation. This dependency is injected through the constructor, following the principle of Dependency Inversion. The PaymentService class has a method called makePayment that takes a payment token and an amount. Inside this method, the payment logic is performed, and the PaymentGateway abstraction is used to process the payment by calling the processPayment method. public class PaymentService { private PaymentGateway paymentGateway ; public PaymentService ( PaymentGateway paymentGateway ){ this . paymentGateway = paymentGateway ; } public boolean makePayment ( String paymentToken , double amount ){ return paymentGateway . processPayment ( paymentToken , amount ); } } To demonstrate the flexibility provided by DIP and IoC, we provide an implementation of the PaymentGateway interface called PayPalGateway . This class includes the specific logic to process payments using the PayPal API. public class PayPalGateway implements PaymentGateway { @Override public boolean processPayment ( String paymentToken , double amount ) { return true ; } } By following DIP and IoC, the PaymentService is decoupled from the specific implementation of the payment gateway. This allows us to easily swap the payment gateway implementation by providing a different implementation of the PaymentGateway interface, such as a StripeGateway class that processes payments using the Stripe API. public class StripeGateway implements PaymentGateway { public boolean processPayment ( String paymentToken , double amount ) { // Implementation specific to Stripe payment gateway // Process the payment using the Stripe API return true ; // Payment successful } } Overall, this design promotes modularity, flexibility, and maintainability in the payment service, enabling easy integration of different payment gateways without modifying the core logic of the PaymentService class.","title":"Example"},{"location":"SystemDesign/SolidPrinciples/interface-segregation.html","tags":["Design Principles","System Design","Basics","SOLID"],"text":"Introduction The Interface Segregation Principle (ISP) states that clients should not be forced to depend on interfaces they do not use. It promotes the idea of segregating interfaces into smaller, more focused ones to avoid unnecessary dependencies and provide a clear contract for specific functionality. Example In the context of a payment system, we can demonstrate the ISP as follows: Interfaces OnlinePayment : Declares the processOnlinePayment() method, representing the behavior of processing payments online. public interface OnlinePayment { void processOnlinePayment (); } OfflinePayment : Declares the processOfflinePayment() method, representing the behavior of processing payments offline. public interface OfflinePayment { void processOfflinePayment (); } Implementing Classes CreditCardPayment : Implements the OnlinePayment interface, as credit card payments are typically processed online. It provides the implementation for the processOnlinePayment() method. public class CreditCardPayment implements OnlinePayment { public void processOnlinePayment () { // Process credit card payment online } } CashPayment : Implements the OfflinePayment interface, as cash payments are processed offline. It provides the implementation for the processOfflinePayment() method. public class CashPayment implements OfflinePayment { public void processOfflinePayment () { // Process cash payment offline } } BankTransferPayment : Implements both the OnlinePayment and OfflinePayment interfaces, as bank transfer payments can be processed both online and offline. It provides the implementations for both the processOnlinePayment() and processOfflinePayment() methods. public class BankTransferPayment implements OnlinePayment , OfflinePayment { public void processOnlinePayment () { // Process bank transfer payment online } public void processOfflinePayment () { // Process bank transfer payment offline } } By segregating the interfaces based on their functionality, we ensure that clients only need to implement the interfaces that are relevant to them. This promotes a more focused and cohesive design, as clients are not forced to depend on methods they don't need. The ISP allows for better maintainability, extensibility, and flexibility in the payment system. Clients can depend on the specific interfaces that they require, avoiding unnecessary dependencies and providing a clear contract for their specific needs. This leads to a more robust and scalable system that can accommodate various types of payments.","title":"Interface Segregation Principle"},{"location":"SystemDesign/SolidPrinciples/interface-segregation.html#introduction","text":"The Interface Segregation Principle (ISP) states that clients should not be forced to depend on interfaces they do not use. It promotes the idea of segregating interfaces into smaller, more focused ones to avoid unnecessary dependencies and provide a clear contract for specific functionality.","title":"Introduction"},{"location":"SystemDesign/SolidPrinciples/interface-segregation.html#example","text":"In the context of a payment system, we can demonstrate the ISP as follows:","title":"Example"},{"location":"SystemDesign/SolidPrinciples/interface-segregation.html#interfaces","text":"OnlinePayment : Declares the processOnlinePayment() method, representing the behavior of processing payments online. public interface OnlinePayment { void processOnlinePayment (); } OfflinePayment : Declares the processOfflinePayment() method, representing the behavior of processing payments offline. public interface OfflinePayment { void processOfflinePayment (); }","title":"Interfaces"},{"location":"SystemDesign/SolidPrinciples/interface-segregation.html#implementing-classes","text":"CreditCardPayment : Implements the OnlinePayment interface, as credit card payments are typically processed online. It provides the implementation for the processOnlinePayment() method. public class CreditCardPayment implements OnlinePayment { public void processOnlinePayment () { // Process credit card payment online } } CashPayment : Implements the OfflinePayment interface, as cash payments are processed offline. It provides the implementation for the processOfflinePayment() method. public class CashPayment implements OfflinePayment { public void processOfflinePayment () { // Process cash payment offline } } BankTransferPayment : Implements both the OnlinePayment and OfflinePayment interfaces, as bank transfer payments can be processed both online and offline. It provides the implementations for both the processOnlinePayment() and processOfflinePayment() methods. public class BankTransferPayment implements OnlinePayment , OfflinePayment { public void processOnlinePayment () { // Process bank transfer payment online } public void processOfflinePayment () { // Process bank transfer payment offline } } By segregating the interfaces based on their functionality, we ensure that clients only need to implement the interfaces that are relevant to them. This promotes a more focused and cohesive design, as clients are not forced to depend on methods they don't need. The ISP allows for better maintainability, extensibility, and flexibility in the payment system. Clients can depend on the specific interfaces that they require, avoiding unnecessary dependencies and providing a clear contract for their specific needs. This leads to a more robust and scalable system that can accommodate various types of payments.","title":"Implementing Classes"},{"location":"SystemDesign/SolidPrinciples/liskovs-substitution.html","tags":["Design Principles","System Design","Basics","SOLID"],"text":"Introduction Liskov's Substitution Principle (LSP) states that objects of a superclass should be substitutable with objects of its subclasses without affecting the correctness of the program. In other words, if a program is designed to work with a certain type, it should also work correctly with any subtype of that type. More formally, the principle can be defined as follows: Let q(x) be a property provable about objects x of type T. Then q(y) should be provable for objects y of type S, where S is a subtype of T. Example Interfaces and Payment Method Classes: The PaymentMethod interface defines the contract that all payment methods must adhere to. It declares the processPayment() method, responsible for processing a payment with a specific payment method. public interface PaymentMethod { void processPayment ( double amount ); } Each payment method is implemented as a separate class that implements the PaymentMethod interface. In this example, we have three payment method classes: CreditCardPayment , BankTransferPayment , and EWalletPayment . package solid_principles.liskovs_principle ; public class CreditCardPayment implements CreditCardAdditional { private String cardNumber ; private String cardHolderName ; private String expiryDate ; private String cvv ; public CreditCardPayment ( String cardNumber , String cardHolderName , String expiryDate , String cvv ) { this . cardNumber = cardNumber ; this . cardHolderName = cardHolderName ; this . expiryDate = expiryDate ; this . cvv = cvv ; } @Override public void processPayment ( double amount ) { // Logic to process payment using credit card details System . out . println ( \"Processing credit card payment of $\" + amount ); // Additional implementation specific to credit card payments // ... } @Override public void additionalMethod () { } } public class EWalletPayment implements PaymentMethod { private String eWalletId ; private String password ; public EWalletPayment ( String eWalletId , String password ) { this . eWalletId = eWalletId ; this . password = password ; } @Override public void processPayment ( double amount ) { // Logic to process payment using e-wallet System . out . println ( \"Processing e-wallet payment of $\" + amount ); // Additional implementation specific to e-wallet payments // ... } } public class BankTransferPayment implements PaymentMethod { private String accountNumber ; private String bankCode ; public BankTransferPayment ( String accountNumber , String bankCode ) { this . accountNumber = accountNumber ; this . bankCode = bankCode ; } @Override public void processPayment ( double amount ) { // Logic to process payment via bank transfer System . out . println ( \"Processing bank transfer payment of $\" + amount ); // Additional implementation specific to bank transfers // ... } } Each payment method class contains specific data and logic related to that payment method. For example, the CreditCardPayment class stores the credit card number, cardholder name, expiry date, and CVV. The BankTransferPayment class stores the account number and bank code. The EWalletPayment class stores the e-wallet ID and password. PaymentSystem Class: The PaymentSystem class represents the core of the payment system. It contains the makePayment() method, responsible for handling the payment processing. The makePayment() method takes two parameters: the payment amount ( double ) and the selected payment method ( PaymentMethod ). Inside the makePayment() method, the processPayment() method of the selected payment method is called to perform the actual payment processing. By using the PaymentMethod interface as the parameter type, the PaymentSystem class can work with any class that implements the PaymentMethod interface, providing flexibility and extensibility to support new payment methods in the future. public class PaymentSystem { public void makePayment ( double amount , PaymentMethod paymentMethod ) { paymentMethod . processPayment ( amount ); } } Main Class: The Main class serves as the entry point of the program and demonstrates how the payment system is used. In the main() method, an instance of the PaymentSystem class is created. Instances of different payment methods ( CreditCardPayment , BankTransferPayment , and EWalletPayment ) are created, representing different ways users can make payments. The makePayment() method is called on the PaymentSystem instance, passing the payment amount and the respective payment method as arguments. The payment system then delegates the payment processing to the appropriate payment method based on the provided PaymentMethod object. public class Main { public static void main ( String [] args ) { PaymentSystem paymentSystem = new PaymentSystem (); // Credit card payment PaymentMethod creditCardPayment = new CreditCardPayment ( \"1234567890123456\" , \"John Doe\" , \"12/25\" , \"123\" ); paymentSystem . makePayment ( 100.0 , creditCardPayment ); // Bank transfer payment PaymentMethod bankTransferPayment = new BankTransferPayment ( \"1234567890\" , \"ABC\" ); paymentSystem . makePayment ( 200.0 , bankTransferPayment ); // E-wallet payment PaymentMethod eWalletPayment = new EWalletPayment ( \"john.doe@example.com\" , \"password123\" ); paymentSystem . makePayment ( 50.0 , eWalletPayment ); } } How Liskov's Principle is handled. Interface Contract : The PaymentMethod interface establishes a contract that all payment methods must adhere to. It declares the processPayment() method, responsible for processing a payment. By defining this common method in the interface, it ensures that any class implementing the interface can be used interchangeably wherever a PaymentMethod object is expected. This adherence to a common contract is a key aspect of the LSP. Behavior Preservation : The PaymentMethod interface guarantees that any class implementing it will provide the necessary behavior for processing a payment. This means that each payment method class ( CreditCardPayment , BankTransferPayment , EWalletPayment ) must implement the processPayment() method according to its specific requirements. Each implementation is responsible for performing the actual payment processing logic relevant to that payment method. Substitutability : The payment system, represented by the PaymentSystem class, relies on the PaymentMethod interface for its functionality. The makePayment() method of the PaymentSystem class accepts any object that implements the PaymentMethod interface as its second argument. This demonstrates substitutability, as different payment method objects ( CreditCardPayment , BankTransferPayment , EWalletPayment ) can be passed to the makePayment() method without impacting the correctness or behavior of the system. By adhering to the Liskov Substitution Principle, the payment system example ensures that any new payment method can be added by implementing the PaymentMethod interface, and it can seamlessly integrate into the system without breaking its functionality or causing unexpected behavior. This design approach promotes modularity, extensibility, and flexibility in the payment system, while maintaining a consistent interface contract for all payment methods. Note: In order to add new method, to the existing class or new class in that case we need to create new interface.","title":"Liskov's Substitution Principle"},{"location":"SystemDesign/SolidPrinciples/liskovs-substitution.html#introduction","text":"Liskov's Substitution Principle (LSP) states that objects of a superclass should be substitutable with objects of its subclasses without affecting the correctness of the program. In other words, if a program is designed to work with a certain type, it should also work correctly with any subtype of that type. More formally, the principle can be defined as follows: Let q(x) be a property provable about objects x of type T. Then q(y) should be provable for objects y of type S, where S is a subtype of T.","title":"Introduction"},{"location":"SystemDesign/SolidPrinciples/liskovs-substitution.html#example","text":"","title":"Example"},{"location":"SystemDesign/SolidPrinciples/liskovs-substitution.html#interfaces-and-payment-method-classes","text":"The PaymentMethod interface defines the contract that all payment methods must adhere to. It declares the processPayment() method, responsible for processing a payment with a specific payment method. public interface PaymentMethod { void processPayment ( double amount ); } Each payment method is implemented as a separate class that implements the PaymentMethod interface. In this example, we have three payment method classes: CreditCardPayment , BankTransferPayment , and EWalletPayment . package solid_principles.liskovs_principle ; public class CreditCardPayment implements CreditCardAdditional { private String cardNumber ; private String cardHolderName ; private String expiryDate ; private String cvv ; public CreditCardPayment ( String cardNumber , String cardHolderName , String expiryDate , String cvv ) { this . cardNumber = cardNumber ; this . cardHolderName = cardHolderName ; this . expiryDate = expiryDate ; this . cvv = cvv ; } @Override public void processPayment ( double amount ) { // Logic to process payment using credit card details System . out . println ( \"Processing credit card payment of $\" + amount ); // Additional implementation specific to credit card payments // ... } @Override public void additionalMethod () { } } public class EWalletPayment implements PaymentMethod { private String eWalletId ; private String password ; public EWalletPayment ( String eWalletId , String password ) { this . eWalletId = eWalletId ; this . password = password ; } @Override public void processPayment ( double amount ) { // Logic to process payment using e-wallet System . out . println ( \"Processing e-wallet payment of $\" + amount ); // Additional implementation specific to e-wallet payments // ... } } public class BankTransferPayment implements PaymentMethod { private String accountNumber ; private String bankCode ; public BankTransferPayment ( String accountNumber , String bankCode ) { this . accountNumber = accountNumber ; this . bankCode = bankCode ; } @Override public void processPayment ( double amount ) { // Logic to process payment via bank transfer System . out . println ( \"Processing bank transfer payment of $\" + amount ); // Additional implementation specific to bank transfers // ... } } Each payment method class contains specific data and logic related to that payment method. For example, the CreditCardPayment class stores the credit card number, cardholder name, expiry date, and CVV. The BankTransferPayment class stores the account number and bank code. The EWalletPayment class stores the e-wallet ID and password.","title":"Interfaces and Payment Method Classes:"},{"location":"SystemDesign/SolidPrinciples/liskovs-substitution.html#paymentsystem-class","text":"The PaymentSystem class represents the core of the payment system. It contains the makePayment() method, responsible for handling the payment processing. The makePayment() method takes two parameters: the payment amount ( double ) and the selected payment method ( PaymentMethod ). Inside the makePayment() method, the processPayment() method of the selected payment method is called to perform the actual payment processing. By using the PaymentMethod interface as the parameter type, the PaymentSystem class can work with any class that implements the PaymentMethod interface, providing flexibility and extensibility to support new payment methods in the future. public class PaymentSystem { public void makePayment ( double amount , PaymentMethod paymentMethod ) { paymentMethod . processPayment ( amount ); } }","title":"PaymentSystem Class:"},{"location":"SystemDesign/SolidPrinciples/liskovs-substitution.html#main-class","text":"The Main class serves as the entry point of the program and demonstrates how the payment system is used. In the main() method, an instance of the PaymentSystem class is created. Instances of different payment methods ( CreditCardPayment , BankTransferPayment , and EWalletPayment ) are created, representing different ways users can make payments. The makePayment() method is called on the PaymentSystem instance, passing the payment amount and the respective payment method as arguments. The payment system then delegates the payment processing to the appropriate payment method based on the provided PaymentMethod object. public class Main { public static void main ( String [] args ) { PaymentSystem paymentSystem = new PaymentSystem (); // Credit card payment PaymentMethod creditCardPayment = new CreditCardPayment ( \"1234567890123456\" , \"John Doe\" , \"12/25\" , \"123\" ); paymentSystem . makePayment ( 100.0 , creditCardPayment ); // Bank transfer payment PaymentMethod bankTransferPayment = new BankTransferPayment ( \"1234567890\" , \"ABC\" ); paymentSystem . makePayment ( 200.0 , bankTransferPayment ); // E-wallet payment PaymentMethod eWalletPayment = new EWalletPayment ( \"john.doe@example.com\" , \"password123\" ); paymentSystem . makePayment ( 50.0 , eWalletPayment ); } }","title":"Main Class:"},{"location":"SystemDesign/SolidPrinciples/liskovs-substitution.html#how-liskovs-principle-is-handled","text":"Interface Contract : The PaymentMethod interface establishes a contract that all payment methods must adhere to. It declares the processPayment() method, responsible for processing a payment. By defining this common method in the interface, it ensures that any class implementing the interface can be used interchangeably wherever a PaymentMethod object is expected. This adherence to a common contract is a key aspect of the LSP. Behavior Preservation : The PaymentMethod interface guarantees that any class implementing it will provide the necessary behavior for processing a payment. This means that each payment method class ( CreditCardPayment , BankTransferPayment , EWalletPayment ) must implement the processPayment() method according to its specific requirements. Each implementation is responsible for performing the actual payment processing logic relevant to that payment method. Substitutability : The payment system, represented by the PaymentSystem class, relies on the PaymentMethod interface for its functionality. The makePayment() method of the PaymentSystem class accepts any object that implements the PaymentMethod interface as its second argument. This demonstrates substitutability, as different payment method objects ( CreditCardPayment , BankTransferPayment , EWalletPayment ) can be passed to the makePayment() method without impacting the correctness or behavior of the system. By adhering to the Liskov Substitution Principle, the payment system example ensures that any new payment method can be added by implementing the PaymentMethod interface, and it can seamlessly integrate into the system without breaking its functionality or causing unexpected behavior. This design approach promotes modularity, extensibility, and flexibility in the payment system, while maintaining a consistent interface contract for all payment methods. Note: In order to add new method, to the existing class or new class in that case we need to create new interface.","title":"How Liskov's Principle is handled."},{"location":"SystemDesign/SolidPrinciples/open-closed.html","tags":["Design Principles","System Design","Basics","SOLID"],"text":"Introduction Example Consider a system that processes payments using different payment methods, such as credit card, PayPal, and bank transfer. Without OCP The payment logic is implemented within a single class: class PaymentProcessor { public void processPayment ( String paymentMethod ) { if ( paymentMethod . equals ( \"credit_card\" )) { // Process credit card payment logic } else if ( paymentMethod . equals ( \"paypal\" )) { // Process PayPal payment logic } else if ( paymentMethod . equals ( \"bank_transfer\" )) { // Process bank transfer logic } } } In this example, the processPayment() method in the PaymentProcessor class checks the payment method type and performs the corresponding payment processing logic. However, if a new payment method is introduced, we would need to modify the PaymentProcessor class, violating the Open-Closed Principle. Following OCP interface PaymentMethod { void processPayment (); } class CreditCardPayment implements PaymentMethod { public void processPayment () { // Process credit card payment logic } } class PayPalPayment implements PaymentMethod { public void processPayment () { // Process PayPal payment logic } } class BankTransferPayment implements PaymentMethod { public void processPayment () { // Process bank transfer logic } } In the improved example, we define an interface called PaymentMethod with a processPayment() method. Each specific payment method class ( CreditCardPayment , PayPalPayment , BankTransferPayment ) implements this interface and provides its own implementation of the processPayment() method. This allows new payment methods to be added by creating additional classes that implement the PaymentMethod interface, without modifying existing classes. By following the Open-Closed Principle, we design our systems to be open for extension by allowing new functionality to be added through inheritance or interface implementation, while closed for modification, ensuring that existing code remains unchanged.","title":"Open for Extension Closed for Modification"},{"location":"SystemDesign/SolidPrinciples/open-closed.html#introduction","text":"","title":"Introduction"},{"location":"SystemDesign/SolidPrinciples/open-closed.html#example","text":"Consider a system that processes payments using different payment methods, such as credit card, PayPal, and bank transfer.","title":"Example"},{"location":"SystemDesign/SolidPrinciples/open-closed.html#without-ocp","text":"The payment logic is implemented within a single class: class PaymentProcessor { public void processPayment ( String paymentMethod ) { if ( paymentMethod . equals ( \"credit_card\" )) { // Process credit card payment logic } else if ( paymentMethod . equals ( \"paypal\" )) { // Process PayPal payment logic } else if ( paymentMethod . equals ( \"bank_transfer\" )) { // Process bank transfer logic } } } In this example, the processPayment() method in the PaymentProcessor class checks the payment method type and performs the corresponding payment processing logic. However, if a new payment method is introduced, we would need to modify the PaymentProcessor class, violating the Open-Closed Principle.","title":"Without OCP"},{"location":"SystemDesign/SolidPrinciples/open-closed.html#following-ocp","text":"interface PaymentMethod { void processPayment (); } class CreditCardPayment implements PaymentMethod { public void processPayment () { // Process credit card payment logic } } class PayPalPayment implements PaymentMethod { public void processPayment () { // Process PayPal payment logic } } class BankTransferPayment implements PaymentMethod { public void processPayment () { // Process bank transfer logic } } In the improved example, we define an interface called PaymentMethod with a processPayment() method. Each specific payment method class ( CreditCardPayment , PayPalPayment , BankTransferPayment ) implements this interface and provides its own implementation of the processPayment() method. This allows new payment methods to be added by creating additional classes that implement the PaymentMethod interface, without modifying existing classes. By following the Open-Closed Principle, we design our systems to be open for extension by allowing new functionality to be added through inheritance or interface implementation, while closed for modification, ensuring that existing code remains unchanged.","title":"Following OCP"},{"location":"SystemDesign/SolidPrinciples/single-responsibility.html","tags":["Design Principles","System Design","Basics","SOLID"],"text":"Introduction The Single Responsibility Principle (SRP) is a software development principle that states that a class or module should have only one reason to change. In other words, a class should have a single responsibility or job, and that responsibility should be encapsulated within the class. Example Without SRP In this example the User class has multiple responsibilities. Authentication Responsibility : The User class has a method authenticate() that handles user authentication logic. This method checks the username and password and performs the necessary authentication procedures. This is a significant responsibility on its own. Persistence Responsibility : The User class also has a method save() that handles saving the user to the database. It contains logic for connecting to the database and storing user data. This is another distinct responsibility that should be separated. Email Sending Responsibility : Additionally, the User class has a method sendEmail() that handles sending emails. It contains the logic for composing and sending email messages. This responsibility is unrelated to authentication or persistence and should be separate. This violates the Single Responsibility Principle because the User class has multiple reasons to change. Any modifications or bug fixes related to authentication, persistence, or email sending could potentially impact other parts of the class. It also makes the class harder to understand, test, and maintain. public class User { private String username ; private String password ; /** * Handles user authentication logic. * This method checks the username and password and performs the necessary authentication procedures. * This is a significant responsibility on its own. */ public void authenticate (){ } /** * Handles saving the user to the database. * It contains logic for connecting to the database and storing user data. * This is another distinct responsibility that should be separated. * @param user */ public void save ( User user ){ } /** * Handles sending emails. * It contains the logic for composing and sending email messages. * This responsibility is unrelated to authentication or persistence and should be separate. * @param user * @param message */ public void sendEmail ( User user , String message ){ } } With SRP class UserAuthenticator { public void authenticate () { // Authentication logic } } class UserRepository { public void save ( User user ) { // Save user to the database logic } } class EmailService { public void sendEmail ( User user , String message ) { // Send email logic } } public class User { private String username ; private String password ; } UserAuthenticator class : This class is responsible for handling user authentication. It contains the logic for verifying user credentials, interacting with authentication mechanisms, and ensuring the user is authenticated. By separating this responsibility into its own class, we have a clear and focused implementation for authentication-related operations. UserRepository class : This class is responsible for saving user data to the database. It provides methods for interacting with the database, such as inserting or updating user records. By isolating the persistence responsibility in a separate class, we have a dedicated place for handling database operations. EmailService class : This class is responsible for sending emails. It encapsulates the logic for composing email messages, connecting to an email server, and sending the messages. By abstracting the email sending functionality into its own class, we have a modular and reusable component for handling email-related tasks. By adhering to the Single Responsibility Principle, each class now has a clearly defined and single responsibility. It improves code organization, makes the classes more focused and understandable, and allows for easier maintenance and future enhancements. Each class can be independently modified or replaced without affecting the others, promoting code modularity and extensibility.","title":"Single Responsibility Principle"},{"location":"SystemDesign/SolidPrinciples/single-responsibility.html#introduction","text":"The Single Responsibility Principle (SRP) is a software development principle that states that a class or module should have only one reason to change. In other words, a class should have a single responsibility or job, and that responsibility should be encapsulated within the class.","title":"Introduction"},{"location":"SystemDesign/SolidPrinciples/single-responsibility.html#example","text":"","title":"Example"},{"location":"SystemDesign/SolidPrinciples/single-responsibility.html#without-srp","text":"In this example the User class has multiple responsibilities. Authentication Responsibility : The User class has a method authenticate() that handles user authentication logic. This method checks the username and password and performs the necessary authentication procedures. This is a significant responsibility on its own. Persistence Responsibility : The User class also has a method save() that handles saving the user to the database. It contains logic for connecting to the database and storing user data. This is another distinct responsibility that should be separated. Email Sending Responsibility : Additionally, the User class has a method sendEmail() that handles sending emails. It contains the logic for composing and sending email messages. This responsibility is unrelated to authentication or persistence and should be separate. This violates the Single Responsibility Principle because the User class has multiple reasons to change. Any modifications or bug fixes related to authentication, persistence, or email sending could potentially impact other parts of the class. It also makes the class harder to understand, test, and maintain. public class User { private String username ; private String password ; /** * Handles user authentication logic. * This method checks the username and password and performs the necessary authentication procedures. * This is a significant responsibility on its own. */ public void authenticate (){ } /** * Handles saving the user to the database. * It contains logic for connecting to the database and storing user data. * This is another distinct responsibility that should be separated. * @param user */ public void save ( User user ){ } /** * Handles sending emails. * It contains the logic for composing and sending email messages. * This responsibility is unrelated to authentication or persistence and should be separate. * @param user * @param message */ public void sendEmail ( User user , String message ){ } }","title":"Without SRP"},{"location":"SystemDesign/SolidPrinciples/single-responsibility.html#with-srp","text":"class UserAuthenticator { public void authenticate () { // Authentication logic } } class UserRepository { public void save ( User user ) { // Save user to the database logic } } class EmailService { public void sendEmail ( User user , String message ) { // Send email logic } } public class User { private String username ; private String password ; } UserAuthenticator class : This class is responsible for handling user authentication. It contains the logic for verifying user credentials, interacting with authentication mechanisms, and ensuring the user is authenticated. By separating this responsibility into its own class, we have a clear and focused implementation for authentication-related operations. UserRepository class : This class is responsible for saving user data to the database. It provides methods for interacting with the database, such as inserting or updating user records. By isolating the persistence responsibility in a separate class, we have a dedicated place for handling database operations. EmailService class : This class is responsible for sending emails. It encapsulates the logic for composing email messages, connecting to an email server, and sending the messages. By abstracting the email sending functionality into its own class, we have a modular and reusable component for handling email-related tasks. By adhering to the Single Responsibility Principle, each class now has a clearly defined and single responsibility. It improves code organization, makes the classes more focused and understandable, and allows for easier maintenance and future enhancements. Each class can be independently modified or replaced without affecting the others, promoting code modularity and extensibility.","title":"With SRP"},{"location":"leetcode-Contests/weekly-contest-347/difference-of-number-of-distinct-values-on-diagonals.html","tags":["Arrays","Contest"],"text":"Problem Statement Given a 0-indexed 2D grid of size m x n , you should find the matrix answer of size m x n . The value of each cell (r, c) of the matrix answer is calculated in the following way: Let topLeft[r][c] be the number of distinct values in the top-left diagonal of the cell (r, c) in the matrix grid . Let bottomRight[r][c] be the number of distinct values in the bottom-right diagonal of the cell (r, c) in the matrix grid . Then answer[r][c] = |topLeft[r][c] - bottomRight[r][c]| . Return the matrix answer . A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix's end. A cell (r<sub>1</sub>, c<sub>1</sub>) belongs to the top-left diagonal of the cell (r, c) , if both belong to the same diagonal and r<sub>1</sub> < r . Similarly is defined bottom-right diagonal. Example 1: Input: grid = [[1,2,3],[3,1,5],[3,2,1]] Output: [[1,1,0],[1,0,1],[0,1,1]] Explanation: The 1st diagram denotes the initial grid. The 2nd diagram denotes a grid for cell (0,0), where blue-colored cells are cells on its bottom-right diagonal. The 3rd diagram denotes a grid for cell (1,2), where red-colored cells are cells on its top-left diagonal. The 4th diagram denotes a grid for cell (1,1), where blue-colored cells are cells on its bottom-right diagonal and red-colored cells are cells on its top-left diagonal. - The cell (0,0) contains [1,1] on its bottom-right diagonal and [] on its top-left diagonal. The answer is |1 - 0| = 1. - The cell (1,2) contains [] on its bottom-right diagonal and [2] on its top-left diagonal. The answer is |0 - 1| = 1. - The cell (1,1) contains [1] on its bottom-right diagonal and [1] on its top-left diagonal. The answer is |1 - 1| = 0. The answers of other cells are similarly calculated. Example 2: Input: grid = [[1]] Output: [[0]] Explanation: - The cell (0,0) contains [] on its bottom-right diagonal and [] on its top-left diagonal. The answer is |0 - 0| = 0. Constraints: m == grid.length n == grid[i].length 1 <= m, n, grid[i][j] <= 50 Solution class Solution : def differenceOfDistinctValues ( self , grid : List [ List [ int ]]) -> List [ List [ int ]]: n , m = len ( grid ), len ( grid [ 0 ]) res = [[ 0 ] * m for _ in range ( n )] def topLeft ( i , j ): unique = set () while ( i > - 1 and j > - 1 ): unique . add ( grid [ i ][ j ]) i -= 1 j -= 1 return len ( unique ) def bottomRight ( i , j ): unique = set () while ( i < n and j < m ): unique . add ( grid [ i ][ j ]) i += 1 j += 1 return len ( unique ) for i in range ( n ): for j in range ( m ): res [ i ][ j ] = abs ( topLeft ( i - 1 , j - 1 ) - bottomRight ( i + 1 , j + 1 )) return res","title":"2711. Difference of Number of Distinct Values on Diagonals"},{"location":"leetcode-Contests/weekly-contest-347/difference-of-number-of-distinct-values-on-diagonals.html#problem-statement","text":"Given a 0-indexed 2D grid of size m x n , you should find the matrix answer of size m x n . The value of each cell (r, c) of the matrix answer is calculated in the following way: Let topLeft[r][c] be the number of distinct values in the top-left diagonal of the cell (r, c) in the matrix grid . Let bottomRight[r][c] be the number of distinct values in the bottom-right diagonal of the cell (r, c) in the matrix grid . Then answer[r][c] = |topLeft[r][c] - bottomRight[r][c]| . Return the matrix answer . A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix's end. A cell (r<sub>1</sub>, c<sub>1</sub>) belongs to the top-left diagonal of the cell (r, c) , if both belong to the same diagonal and r<sub>1</sub> < r . Similarly is defined bottom-right diagonal. Example 1: Input: grid = [[1,2,3],[3,1,5],[3,2,1]] Output: [[1,1,0],[1,0,1],[0,1,1]] Explanation: The 1st diagram denotes the initial grid. The 2nd diagram denotes a grid for cell (0,0), where blue-colored cells are cells on its bottom-right diagonal. The 3rd diagram denotes a grid for cell (1,2), where red-colored cells are cells on its top-left diagonal. The 4th diagram denotes a grid for cell (1,1), where blue-colored cells are cells on its bottom-right diagonal and red-colored cells are cells on its top-left diagonal. - The cell (0,0) contains [1,1] on its bottom-right diagonal and [] on its top-left diagonal. The answer is |1 - 0| = 1. - The cell (1,2) contains [] on its bottom-right diagonal and [2] on its top-left diagonal. The answer is |0 - 1| = 1. - The cell (1,1) contains [1] on its bottom-right diagonal and [1] on its top-left diagonal. The answer is |1 - 1| = 0. The answers of other cells are similarly calculated. Example 2: Input: grid = [[1]] Output: [[0]] Explanation: - The cell (0,0) contains [] on its bottom-right diagonal and [] on its top-left diagonal. The answer is |0 - 0| = 0. Constraints: m == grid.length n == grid[i].length 1 <= m, n, grid[i][j] <= 50","title":"Problem Statement"},{"location":"leetcode-Contests/weekly-contest-347/difference-of-number-of-distinct-values-on-diagonals.html#solution","text":"class Solution : def differenceOfDistinctValues ( self , grid : List [ List [ int ]]) -> List [ List [ int ]]: n , m = len ( grid ), len ( grid [ 0 ]) res = [[ 0 ] * m for _ in range ( n )] def topLeft ( i , j ): unique = set () while ( i > - 1 and j > - 1 ): unique . add ( grid [ i ][ j ]) i -= 1 j -= 1 return len ( unique ) def bottomRight ( i , j ): unique = set () while ( i < n and j < m ): unique . add ( grid [ i ][ j ]) i += 1 j += 1 return len ( unique ) for i in range ( n ): for j in range ( m ): res [ i ][ j ] = abs ( topLeft ( i - 1 , j - 1 ) - bottomRight ( i + 1 , j + 1 )) return res","title":"Solution"},{"location":"leetcode-Contests/weekly-contest-347/maximum-strictly-increasing-cells-in-a-matrix.html","tags":["DP","Contest"],"text":"Problem Statement Given a 1-indexed m x n integer matrix mat , you can select any cell in the matrix as your starting cell . From the starting cell, you can move to any other cell in the same row or column , but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves. Your task is to find the maximum number of cells that you can visit in the matrix by starting from some cell. Return an integer denoting the maximum number of cells that can be visited. Example 1: Input: mat = [[3,1],[3,4]] Output: 2 Explanation: The image shows how we can visit 2 cells starting from row 1, column 2. It can be shown that we cannot visit more than 2 cells no matter where we start from, so the answer is 2. Example 2: Input: mat = [[1,1],[1,1]] Output: 1 Explanation: Since the cells must be strictly increasing, we can only visit one cell in this example. Example 3: Input: mat = [[3,1,6],[-9,5,7]] Output: 4 Explanation: The image above shows how we can visit 4 cells starting from row 2, column 1. It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. Constraints: m == mat.length n == mat[i].length 1 <= m, n <= 10<sup>5</sup> 1 <= m * n <= 10<sup>5</sup> -10<sup>5</sup> <= mat[i][j] <= 10<sup>5</sup> Solution class Solution : def maxIncreasingCells ( self , grid : List [ List [ int ]]) -> int : elements = defaultdict ( list ) n , m = len ( grid ), len ( grid [ 0 ]) for i in range ( 0 , len ( grid )): for j in range ( 0 , len ( grid [ 0 ])): elements [ grid [ i ][ j ]] . append ([ i , j ]) res = [ 0 ] * ( n + m ) dp = [[ 0 ] * m for _ in range ( n )] for element in sorted ( elements ): for i , j in elements [ element ]: dp [ i ][ j ] = max ( res [ i ], res [ ~ j ]) + 1 for i , j in elements [ element ]: res [ i ] = max ( res [ i ], dp [ i ][ j ]) res [ ~ j ] = max ( res [ ~ j ], dp [ i ][ j ]) return max ( res )","title":"2713. Maximum Strictly Increasing Cells in a Matrix"},{"location":"leetcode-Contests/weekly-contest-347/maximum-strictly-increasing-cells-in-a-matrix.html#problem-statement","text":"Given a 1-indexed m x n integer matrix mat , you can select any cell in the matrix as your starting cell . From the starting cell, you can move to any other cell in the same row or column , but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves. Your task is to find the maximum number of cells that you can visit in the matrix by starting from some cell. Return an integer denoting the maximum number of cells that can be visited. Example 1: Input: mat = [[3,1],[3,4]] Output: 2 Explanation: The image shows how we can visit 2 cells starting from row 1, column 2. It can be shown that we cannot visit more than 2 cells no matter where we start from, so the answer is 2. Example 2: Input: mat = [[1,1],[1,1]] Output: 1 Explanation: Since the cells must be strictly increasing, we can only visit one cell in this example. Example 3: Input: mat = [[3,1,6],[-9,5,7]] Output: 4 Explanation: The image above shows how we can visit 4 cells starting from row 2, column 1. It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. Constraints: m == mat.length n == mat[i].length 1 <= m, n <= 10<sup>5</sup> 1 <= m * n <= 10<sup>5</sup> -10<sup>5</sup> <= mat[i][j] <= 10<sup>5</sup>","title":"Problem Statement"},{"location":"leetcode-Contests/weekly-contest-347/maximum-strictly-increasing-cells-in-a-matrix.html#solution","text":"class Solution : def maxIncreasingCells ( self , grid : List [ List [ int ]]) -> int : elements = defaultdict ( list ) n , m = len ( grid ), len ( grid [ 0 ]) for i in range ( 0 , len ( grid )): for j in range ( 0 , len ( grid [ 0 ])): elements [ grid [ i ][ j ]] . append ([ i , j ]) res = [ 0 ] * ( n + m ) dp = [[ 0 ] * m for _ in range ( n )] for element in sorted ( elements ): for i , j in elements [ element ]: dp [ i ][ j ] = max ( res [ i ], res [ ~ j ]) + 1 for i , j in elements [ element ]: res [ i ] = max ( res [ i ], dp [ i ][ j ]) res [ ~ j ] = max ( res [ ~ j ], dp [ i ][ j ]) return max ( res )","title":"Solution"},{"location":"leetcode-Contests/weekly-contest-347/minimum-cost-to-make-all-characters-equal.html","tags":["DP","Contest"],"text":"Problem Statement You are given a 0-indexed binary string s of length n on which you can apply two types of operations: Choose an index i and invert all characters from index 0 to index i (both inclusive), with a cost of i + 1 Choose an index i and invert all characters from index i to index n - 1 (both inclusive), with a cost of n - i Return the minimum cost to make all characters of the string equal . Invert a character means if its value is '0' it becomes '1' and vice-versa. Example 1: Input: s = \"0011\" Output: 2 Explanation: Apply the second operation with i = 2 to obtain s = \"0000\" for a cost of 2. It can be shown that 2 is the minimum cost to make all characters equal. Example 2: Input: s = \"010101\" Output: 9 Explanation: Apply the first operation with i = 2 to obtain s = \"101101\" for a cost of 3. Apply the first operation with i = 1 to obtain s = \"011101\" for a cost of 2. Apply the first operation with i = 0 to obtain s = \"111101\" for a cost of 1. Apply the second operation with i = 4 to obtain s = \"111110\" for a cost of 2. Apply the second operation with i = 5 to obtain s = \"111111\" for a cost of 1. The total cost to make all characters equal is 9. It can be shown that 9 is the minimum cost to make all characters equal. Constraints: 1 <= s.length == n <= 10<sup>5</sup> s[i] is either '0' or '1' Solution class Solution : def minimumCost ( self , s : str ) -> int : dp = [ 0 ] * len ( s ) for i in range ( 1 , len ( s )): if ( s [ i ] != s [ i - 1 ]): dp [ i ] = dp [ i - 1 ] + i else : dp [ i ] = dp [ i - 1 ] result = dp [ - 1 ] right = 0 for j in range ( len ( s ) - 2 , - 1 , - 1 ): if ( s [ j ] != s [ j + 1 ]): right += ( len ( s ) - j - 1 ) result = min ( result , right + dp [ j ]) return result","title":"2712. Minimum Cost to Make All Characters Equal"},{"location":"leetcode-Contests/weekly-contest-347/minimum-cost-to-make-all-characters-equal.html#problem-statement","text":"You are given a 0-indexed binary string s of length n on which you can apply two types of operations: Choose an index i and invert all characters from index 0 to index i (both inclusive), with a cost of i + 1 Choose an index i and invert all characters from index i to index n - 1 (both inclusive), with a cost of n - i Return the minimum cost to make all characters of the string equal . Invert a character means if its value is '0' it becomes '1' and vice-versa. Example 1: Input: s = \"0011\" Output: 2 Explanation: Apply the second operation with i = 2 to obtain s = \"0000\" for a cost of 2. It can be shown that 2 is the minimum cost to make all characters equal. Example 2: Input: s = \"010101\" Output: 9 Explanation: Apply the first operation with i = 2 to obtain s = \"101101\" for a cost of 3. Apply the first operation with i = 1 to obtain s = \"011101\" for a cost of 2. Apply the first operation with i = 0 to obtain s = \"111101\" for a cost of 1. Apply the second operation with i = 4 to obtain s = \"111110\" for a cost of 2. Apply the second operation with i = 5 to obtain s = \"111111\" for a cost of 1. The total cost to make all characters equal is 9. It can be shown that 9 is the minimum cost to make all characters equal. Constraints: 1 <= s.length == n <= 10<sup>5</sup> s[i] is either '0' or '1'","title":"Problem Statement"},{"location":"leetcode-Contests/weekly-contest-347/minimum-cost-to-make-all-characters-equal.html#solution","text":"class Solution : def minimumCost ( self , s : str ) -> int : dp = [ 0 ] * len ( s ) for i in range ( 1 , len ( s )): if ( s [ i ] != s [ i - 1 ]): dp [ i ] = dp [ i - 1 ] + i else : dp [ i ] = dp [ i - 1 ] result = dp [ - 1 ] right = 0 for j in range ( len ( s ) - 2 , - 1 , - 1 ): if ( s [ j ] != s [ j + 1 ]): right += ( len ( s ) - j - 1 ) result = min ( result , right + dp [ j ]) return result","title":"Solution"},{"location":"leetcode-Contests/weekly-contest-347/removing-trailing-zeros-from-a-string.html","tags":["String","Contest"],"text":"Problem Statement Given a positive integer num represented as a string, return the integer num without trailing zeros as a string . Example 1: Input: num = \"51230100\" Output: \"512301\" Explanation: Integer \"51230100\" has 2 trailing zeros, we remove them and return integer \"512301\". Example 2: Input: num = \"123\" Output: \"123\" Explanation: Integer \"123\" has no trailing zeros, we return integer \"123\". Constraints: 1 <= num.length <= 1000 num consists of only digits. num doesn't have any leading zeros. Solution class Solution : def removeTrailingZeros ( self , num : str ) -> str : left , right = 0 , len ( num ) - 1 while ( left < right ): if ( num [ left ] != '0' and num [ right ] != '0' ): break ; if ( num [ left ] == '0' ): left += 1 if ( num [ right ] == '0' ): right -= 1 return num [ left : right + 1 ]","title":"2710. Remove Trailing Zeros From a String"},{"location":"leetcode-Contests/weekly-contest-347/removing-trailing-zeros-from-a-string.html#problem-statement","text":"Given a positive integer num represented as a string, return the integer num without trailing zeros as a string . Example 1: Input: num = \"51230100\" Output: \"512301\" Explanation: Integer \"51230100\" has 2 trailing zeros, we remove them and return integer \"512301\". Example 2: Input: num = \"123\" Output: \"123\" Explanation: Integer \"123\" has no trailing zeros, we return integer \"123\". Constraints: 1 <= num.length <= 1000 num consists of only digits. num doesn't have any leading zeros.","title":"Problem Statement"},{"location":"leetcode-Contests/weekly-contest-347/removing-trailing-zeros-from-a-string.html#solution","text":"class Solution : def removeTrailingZeros ( self , num : str ) -> str : left , right = 0 , len ( num ) - 1 while ( left < right ): if ( num [ left ] != '0' and num [ right ] != '0' ): break ; if ( num [ left ] == '0' ): left += 1 if ( num [ right ] == '0' ): right -= 1 return num [ left : right + 1 ]","title":"Solution"}]}