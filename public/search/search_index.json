{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to Competitive Programming Notes This website contains useful algorithms and problems that helps to prepare for coding interviews Topics Covered Arrays Strings Trees Graphs Dynamic Programming Greedy / BackTracking Sorting Binary Search","title":"Home"},{"location":"index.html#welcome-to-competitive-programming-notes","text":"This website contains useful algorithms and problems that helps to prepare for coding interviews","title":"Welcome to Competitive Programming Notes"},{"location":"index.html#topics-covered","text":"Arrays Strings Trees Graphs Dynamic Programming Greedy / BackTracking Sorting Binary Search","title":"Topics Covered"},{"location":"DynamicProgramming/index.html","text":"Dynamic Programming This pages act as home page for DP concepts Topics 1 Dimensional DP 2 Dimensional DP Partition Combinatorics Subsequences Digit DP Dp on Trees Dp on Graphs Dp on Strings Dp with Bitmasks Gametheory DP Dp with Advance DS","title":"Home"},{"location":"DynamicProgramming/index.html#dynamic-programming","text":"This pages act as home page for DP concepts","title":"Dynamic Programming"},{"location":"DynamicProgramming/index.html#topics","text":"1 Dimensional DP 2 Dimensional DP Partition Combinatorics Subsequences Digit DP Dp on Trees Dp on Graphs Dp on Strings Dp with Bitmasks Gametheory DP Dp with Advance DS","title":"Topics"},{"location":"DynamicProgramming/DigitDp.html","text":"Introduction It's Dynamic Programming Problem Involving digits. The digit problems will be based on some numbers, for eg: from l to r give me numbers which satisfy certain properties.","title":"Digit DP"},{"location":"DynamicProgramming/DigitDp.html#introduction","text":"It's Dynamic Programming Problem Involving digits. The digit problems will be based on some numbers, for eg: from l to r give me numbers which satisfy certain properties.","title":"Introduction"},{"location":"DynamicProgramming/Subsequences.html","text":"","title":"Subsequences"},{"location":"DynamicProgramming/Tree.html","tags":["tree"],"text":"Introduction dp[curr] --> indicates the answers for the subtree of curr. changes with the root of the tree Overall answer will not be changed(i.e on choosing any node to be root), if and only if in the question it is not mentioned any root. Answer will be dp[root]","title":"DP on Trees"},{"location":"DynamicProgramming/Tree.html#introduction","text":"dp[curr] --> indicates the answers for the subtree of curr. changes with the root of the tree Overall answer will not be changed(i.e on choosing any node to be root), if and only if in the question it is not mentioned any root. Answer will be dp[root]","title":"Introduction"},{"location":"DynamicProgramming/Problems/Categories.html","text":"Categories Basics of DP Fibonacci Number Climbing Stairs Min Cost Climbing Stairs One Dimensional DP Maximum Subarray House Robber House Robber-ii P Paint House P Paint House-ii Best time to buy and sell stock Best time to buy and sell stocks with transaction fee Best Time to Buy and Sell Stock with Cooldown Maximum Product Subarray P Max Consecutive Ones II Wiggle Subsequence P Maximum Subarray Sum After One Operation P Toss Strange Coins P Handshakes That Don't Cross Allocate Mailboxes Maximum Profit in Job Scheduling Maximum Number of Events That Can Be Attended II Best Time to Buy and Sell Stock III Best Time to Buy and Sell Stock IV Longest Valid Parenthesis Filling Bookcase Shelves Maximum Profit in Job Scheduling Maximum Number of Events That Can Be Attended II Animals Consecutive Subsequence DP on Strings Longest Common Subsequence Uncrossed Lines Longest Increasing Subsequence Minimum ASCII Delete Sum for Two Strings Number of Longest Increasing Subsequence Longest String Chain Maximum Length of Pair Chain Largest Divisible Subset Palindromic Substrings Longest Palindromic Substring P Shortest Way to Form String Longest Palindromic Subsequence P Longest Palindromic Subsequence - II P Minimum Window Subsequence P Valid Palindrome III Regular Expression Matching Shortest Common Supersequence P Longest Repeating Substring Edit Distance Minimum Number of Arrows to Burst Balloons Distinct Subsequences Non Overlapping Intervals DP on Counting Count Square Submatrices with All Ones Bomb Enemy Number of Dice Rolls With Target Sum Number of Ways to Stay in the Same Place After Some Steps Count All Possible Routes Number of Ways to Form a Target String Given a Dictionary Distinct Subsequences -II Number of Ways to Rearrange Sticks With K Sticks Visible Build Array Where You Can Find The Maximum Exactly K Comparisons Knight Probability in Chessboard P Number of Corner Rectangles P 4 Keys Keyboard P Find the Derangement of An Array P Count Ways to Distribute Candies P Sentence Screen Fitting DP on Trees Unique Binary Search Trees","title":"Categories"},{"location":"DynamicProgramming/Problems/Categories.html#categories","text":"","title":"Categories"},{"location":"DynamicProgramming/Problems/Categories.html#basics-of-dp","text":"Fibonacci Number Climbing Stairs Min Cost Climbing Stairs","title":"Basics of DP"},{"location":"DynamicProgramming/Problems/Categories.html#one-dimensional-dp","text":"Maximum Subarray House Robber House Robber-ii P Paint House P Paint House-ii Best time to buy and sell stock Best time to buy and sell stocks with transaction fee Best Time to Buy and Sell Stock with Cooldown Maximum Product Subarray P Max Consecutive Ones II Wiggle Subsequence P Maximum Subarray Sum After One Operation P Toss Strange Coins P Handshakes That Don't Cross Allocate Mailboxes Maximum Profit in Job Scheduling Maximum Number of Events That Can Be Attended II Best Time to Buy and Sell Stock III Best Time to Buy and Sell Stock IV Longest Valid Parenthesis Filling Bookcase Shelves Maximum Profit in Job Scheduling Maximum Number of Events That Can Be Attended II Animals Consecutive Subsequence","title":"One Dimensional DP"},{"location":"DynamicProgramming/Problems/Categories.html#dp-on-strings","text":"Longest Common Subsequence Uncrossed Lines Longest Increasing Subsequence Minimum ASCII Delete Sum for Two Strings Number of Longest Increasing Subsequence Longest String Chain Maximum Length of Pair Chain Largest Divisible Subset Palindromic Substrings Longest Palindromic Substring P Shortest Way to Form String Longest Palindromic Subsequence P Longest Palindromic Subsequence - II P Minimum Window Subsequence P Valid Palindrome III Regular Expression Matching Shortest Common Supersequence P Longest Repeating Substring Edit Distance Minimum Number of Arrows to Burst Balloons Distinct Subsequences Non Overlapping Intervals","title":"DP on Strings"},{"location":"DynamicProgramming/Problems/Categories.html#dp-on-counting","text":"Count Square Submatrices with All Ones Bomb Enemy Number of Dice Rolls With Target Sum Number of Ways to Stay in the Same Place After Some Steps Count All Possible Routes Number of Ways to Form a Target String Given a Dictionary Distinct Subsequences -II Number of Ways to Rearrange Sticks With K Sticks Visible Build Array Where You Can Find The Maximum Exactly K Comparisons Knight Probability in Chessboard P Number of Corner Rectangles P 4 Keys Keyboard P Find the Derangement of An Array P Count Ways to Distribute Candies P Sentence Screen Fitting","title":"DP on Counting"},{"location":"DynamicProgramming/Problems/Categories.html#dp-on-trees","text":"Unique Binary Search Trees","title":"DP on Trees"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/2313.min-flips-in-binary-tree-to-get-result.html","tags":["DP","Hard","Premium","Leetcode"],"text":"Problem Statement You are given the root of a binary tree with the following properties: Leaf nodes have either the value 0 or 1 , representing false and true respectively. Non-leaf nodes have either the value 2 , 3 , 4 , or 5 , representing the boolean operations OR , AND , XOR , and NOT , respectively. You are also given a boolean result , which is the desired result of the evaluation of the root node. The evaluation of a node is as follows: If the node is a leaf node, the evaluation is the value of the node, i.e. true or false . Otherwise, evaluate the node's children and apply the boolean operation of its value with the children's evaluations. In one operation, you can flip a leaf node, which causes a false node to become true , and a true node to become false . Return the minimum number of operations that need to be performed such that the evaluation of root yields result . It can be shown that there is always a way to achieve result . A leaf node is a node that has zero children. Note: NOT nodes have either a left child or a right child, but other non-leaf nodes have both a left child and a right child. Example 1: ``` Input: root = [3,5,4,2,null,1,1,1,0], result = true Output: 2 Explanation: It can be shown that a minimum of 2 nodes have to be flipped to make the root of the tree evaluate to true. One way to achieve this is shown in the diagram above. ``` Example 2: ``` Input: root = [0], result = false Output: 0 Explanation: The root of the tree already evaluates to false, so 0 nodes have to be flipped. ``` Constraints: The number of nodes in the tree is in the range [1, 10<sup>5</sup>] . 0 <= Node.val <= 5 OR , AND , and XOR nodes have 2 children. NOT nodes have 1 child. Leaf nodes have a value of 0 or 1 . Non-leaf nodes have a value of 2 , 3 , 4 , or 5 . Solution ```python class Solution: def minimumFlips(self, root: Optional[TreeNode], result: bool) -> int: @lru_cache(maxsize = None) def min_operations(root, result): if(not root): return 0 if(root.val <= 1): return 1 if(root.val != result) else 0 if(root.val == 4): if(result): return min(min_operations(root.left, True) + min_operations(root.right, False), min_operations(root.left, False) + min_operations(root.right, True)) else: return min(min_operations(root.left, False) + min_operations(root.right, False), min_operations(root.left, True) + min_operations(root.right, True)) if(root.val == 2): if(not result): return min_operations(root.left, False) + min_operations(root.right, False) else: return min(min_operations(root.left, False) + min_operations(root.right, True), min_operations(root.left, True) + min_operations(root.right, True), min_operations(root.left, True) + min_operations(root.right, False)) if(root.val == 3): if(result): return min_operations(root.left, True) + min_operations(root.right, True) else: return min(min_operations(root.left, False) + min_operations(root.right, True), min_operations(root.left, False) + min_operations(root.right, False), min_operations(root.left, True) + min_operations(root.right, False)) return min_operations(root.left, not result) + min_operations(root.right, not result) return min_operations(root, result) ```","title":"2313. Minimum Flips in Binary Tree to Get Result"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/2313.min-flips-in-binary-tree-to-get-result.html#problem-statement","text":"You are given the root of a binary tree with the following properties: Leaf nodes have either the value 0 or 1 , representing false and true respectively. Non-leaf nodes have either the value 2 , 3 , 4 , or 5 , representing the boolean operations OR , AND , XOR , and NOT , respectively. You are also given a boolean result , which is the desired result of the evaluation of the root node. The evaluation of a node is as follows: If the node is a leaf node, the evaluation is the value of the node, i.e. true or false . Otherwise, evaluate the node's children and apply the boolean operation of its value with the children's evaluations. In one operation, you can flip a leaf node, which causes a false node to become true , and a true node to become false . Return the minimum number of operations that need to be performed such that the evaluation of root yields result . It can be shown that there is always a way to achieve result . A leaf node is a node that has zero children. Note: NOT nodes have either a left child or a right child, but other non-leaf nodes have both a left child and a right child. Example 1: ``` Input: root = [3,5,4,2,null,1,1,1,0], result = true Output: 2 Explanation: It can be shown that a minimum of 2 nodes have to be flipped to make the root of the tree evaluate to true. One way to achieve this is shown in the diagram above. ``` Example 2: ``` Input: root = [0], result = false Output: 0 Explanation: The root of the tree already evaluates to false, so 0 nodes have to be flipped. ``` Constraints: The number of nodes in the tree is in the range [1, 10<sup>5</sup>] . 0 <= Node.val <= 5 OR , AND , and XOR nodes have 2 children. NOT nodes have 1 child. Leaf nodes have a value of 0 or 1 . Non-leaf nodes have a value of 2 , 3 , 4 , or 5 .","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/2313.min-flips-in-binary-tree-to-get-result.html#solution","text":"```python class Solution: def minimumFlips(self, root: Optional[TreeNode], result: bool) -> int: @lru_cache(maxsize = None) def min_operations(root, result): if(not root): return 0 if(root.val <= 1): return 1 if(root.val != result) else 0 if(root.val == 4): if(result): return min(min_operations(root.left, True) + min_operations(root.right, False), min_operations(root.left, False) + min_operations(root.right, True)) else: return min(min_operations(root.left, False) + min_operations(root.right, False), min_operations(root.left, True) + min_operations(root.right, True)) if(root.val == 2): if(not result): return min_operations(root.left, False) + min_operations(root.right, False) else: return min(min_operations(root.left, False) + min_operations(root.right, True), min_operations(root.left, True) + min_operations(root.right, True), min_operations(root.left, True) + min_operations(root.right, False)) if(root.val == 3): if(result): return min_operations(root.left, True) + min_operations(root.right, True) else: return min(min_operations(root.left, False) + min_operations(root.right, True), min_operations(root.left, False) + min_operations(root.right, False), min_operations(root.left, True) + min_operations(root.right, False)) return min_operations(root.left, not result) + min_operations(root.right, not result) return min_operations(root, result) ```","title":"Solution"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/vertex-cover.html","tags":["DP","Spoj"],"text":"Problem Statement You are given an unweighted, undirected tree. Write a program to find a vertex set of minimum size in this tree such that each edge has as least one of its end-points in that set. Solve Input The first line of the input file contains one integer N --- number of nodes in the tree (0 < N <= 100000). Next N -1 lines contain N -1 edges of that tree --- Each line contains a pair ( u , v ) means there is an edge between node u and node v (1 <= u , v <= N ). Output Print number of nodes in the satisfied vertex set on one line. Example 1 ``` Input: 3 1 2 1 3 Output: 1 Explanation: The set can be {1} ``` Example 2 ``` Input: 3 1 2 2 3 Output: 1 Explanation: The set can be {2} ``` Explanation For every node we have 2 options, we include it in the set or not dp[curr][0] -> vertex cover if current node is not in the set of the subtree dp[curr][1] -> vertex cover if the current node is chosen in the set of the subtree for leaf nodes dp[leaf][0] = 0 dp[leaf][1] = 1 Solution ```py from collections import defaultdict n = int(input()) adj = defaultdict(list) dp = [[0] * 2 for _ in range(n + 1)] def find_min_vertex(source, parent): dp[source][0] = 0 dp[source][1] = 1 for child in adj[source]: if(child != parent): find_min_vertex(child, source) dp[source][0] += dp[child][1] dp[source][1] += min(dp[child][0], dp[child][1]) for i in range(n - 1): u, v = map(int, input().split()) adj[u].append(v) adj[v].append(u) find_min_vertex(1, -1) print(min(dp[1][1], dp[1][0])) ```","title":"PT07X - Vertex Cover"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/vertex-cover.html#problem-statement","text":"You are given an unweighted, undirected tree. Write a program to find a vertex set of minimum size in this tree such that each edge has as least one of its end-points in that set. Solve","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/vertex-cover.html#input","text":"The first line of the input file contains one integer N --- number of nodes in the tree (0 < N <= 100000). Next N -1 lines contain N -1 edges of that tree --- Each line contains a pair ( u , v ) means there is an edge between node u and node v (1 <= u , v <= N ).","title":"Input"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/vertex-cover.html#output","text":"Print number of nodes in the satisfied vertex set on one line.","title":"Output"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/vertex-cover.html#example-1","text":"``` Input: 3 1 2 1 3 Output: 1 Explanation: The set can be {1} ```","title":"Example 1"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/vertex-cover.html#example-2","text":"``` Input: 3 1 2 2 3 Output: 1 Explanation: The set can be {2} ```","title":"Example 2"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/vertex-cover.html#explanation","text":"For every node we have 2 options, we include it in the set or not dp[curr][0] -> vertex cover if current node is not in the set of the subtree dp[curr][1] -> vertex cover if the current node is chosen in the set of the subtree for leaf nodes dp[leaf][0] = 0 dp[leaf][1] = 1","title":"Explanation"},{"location":"DynamicProgramming/Problems/Dp-On-Trees/vertex-cover.html#solution","text":"```py from collections import defaultdict n = int(input()) adj = defaultdict(list) dp = [[0] * 2 for _ in range(n + 1)] def find_min_vertex(source, parent): dp[source][0] = 0 dp[source][1] = 1 for child in adj[source]: if(child != parent): find_min_vertex(child, source) dp[source][0] += dp[child][1] dp[source][1] += min(dp[child][0], dp[child][1]) for i in range(n - 1): u, v = map(int, input().split()) adj[u].append(v) adj[v].append(u) find_min_vertex(1, -1) print(min(dp[1][1], dp[1][0])) ```","title":"Solution"},{"location":"DynamicProgramming/Problems/One-Dimensional/1230.toss-strange-coins.html","tags":["DP","Medium","1D"],"text":"Problem Statement To continue using LeetCode Video solutions extension , you have to switch to the old layout of LeetCode (for now). I am working on releasing the new version soon which works with LeetCode's new UI. How to switch to old UI easily: 1. Ensure that \"Opt-in for further beta testing\" is turned ON here . 2. On this problem page, on the top-right of your screen, click on your profile picture and select \"Revert to old version\". Above way didn't work? (click me) (scroll below) Go to Problems List page . On the bottom-right, click on the \"revert\" icon as shown below then refresh this page: Solution python class Solution: def probabilityOfHeads(self, prob: List[float], target: int) -> float: dp = [[0] * (target + 1) for _ in range(len(prob) + 1)] dp[0][0] = 1 for i in range(1, len(prob) + 1): for j in range(0, target + 1): dp[i][j] = (1 - prob[i - 1]) * dp[i - 1][j] if(j > 0): dp[i][j] += prob[i - 1] * dp[i - 1][j - 1] return dp[len(prob)][target]","title":"1230.toss strange coins"},{"location":"DynamicProgramming/Problems/One-Dimensional/1230.toss-strange-coins.html#problem-statement","text":"To continue using LeetCode Video solutions extension , you have to switch to the old layout of LeetCode (for now). I am working on releasing the new version soon which works with LeetCode's new UI.","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/One-Dimensional/1230.toss-strange-coins.html#_1","text":"How to switch to old UI easily: 1. Ensure that \"Opt-in for further beta testing\" is turned ON here . 2. On this problem page, on the top-right of your screen, click on your profile picture and select \"Revert to old version\". Above way didn't work? (click me) (scroll below) Go to Problems List page . On the bottom-right, click on the \"revert\" icon as shown below then refresh this page:","title":""},{"location":"DynamicProgramming/Problems/One-Dimensional/1230.toss-strange-coins.html#solution","text":"python class Solution: def probabilityOfHeads(self, prob: List[float], target: int) -> float: dp = [[0] * (target + 1) for _ in range(len(prob) + 1)] dp[0][0] = 1 for i in range(1, len(prob) + 1): for j in range(0, target + 1): dp[i][j] = (1 - prob[i - 1]) * dp[i - 1][j] if(j > 0): dp[i][j] += prob[i - 1] * dp[i - 1][j - 1] return dp[len(prob)][target]","title":"Solution"},{"location":"DynamicProgramming/Problems/One-Dimensional/1746.maximum-subarray-sum-after-one-operation.html","tags":["DP","Medium","1D"],"text":"Problem Statement You are given an integer array nums . You must perform exactly one operation where you can replace one element nums[i] with nums[i] * nums[i] . Return the maximum possible subarray sum after exactly one operation . The subarray must be non-empty. Example 1: Input: nums = [2,-1,-4,-3] Output: 17 Explanation: You can perform the operation on index 2 (0-indexed) to make nums = [2,-1,16,-3]. Now, the maximum subarray sum is 2 + -1 + 16 = 17. Example 2: Input: nums = [1,-1,1,1,-1,-1,1] Output: 4 Explanation: You can perform the operation on index 1 (0-indexed) to make nums = [1,1,1,1,-1,-1,1]. Now, the maximum subarray sum is 1 + 1 + 1 + 1 = 4. Constraints: 1 <= nums.length <= 10<sup>5</sup> -10<sup>4</sup> <= nums[i] <= 10<sup>4</sup> Solution ```python class Solution: def maxSumAfterOperation(self, nums: List[int]) -> int: result = 0 dp = [0, 0] for i in range(0, len(nums)): dp[1] = max(nums[i] * nums[i] + dp[0] , dp[1] + nums[i]) dp[0] = max(0, dp[0] + nums[i]) result = max(result, dp[1]) return result ```","title":"1746.maximum subarray sum after one operation"},{"location":"DynamicProgramming/Problems/One-Dimensional/1746.maximum-subarray-sum-after-one-operation.html#problem-statement","text":"You are given an integer array nums . You must perform exactly one operation where you can replace one element nums[i] with nums[i] * nums[i] . Return the maximum possible subarray sum after exactly one operation . The subarray must be non-empty. Example 1: Input: nums = [2,-1,-4,-3] Output: 17 Explanation: You can perform the operation on index 2 (0-indexed) to make nums = [2,-1,16,-3]. Now, the maximum subarray sum is 2 + -1 + 16 = 17. Example 2: Input: nums = [1,-1,1,1,-1,-1,1] Output: 4 Explanation: You can perform the operation on index 1 (0-indexed) to make nums = [1,1,1,1,-1,-1,1]. Now, the maximum subarray sum is 1 + 1 + 1 + 1 = 4. Constraints: 1 <= nums.length <= 10<sup>5</sup> -10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/One-Dimensional/1746.maximum-subarray-sum-after-one-operation.html#solution","text":"```python class Solution: def maxSumAfterOperation(self, nums: List[int]) -> int: result = 0 dp = [0, 0] for i in range(0, len(nums)): dp[1] = max(nums[i] * nums[i] + dp[0] , dp[1] + nums[i]) dp[0] = max(0, dp[0] + nums[i]) result = max(result, dp[1]) return result ```","title":"Solution"},{"location":"DynamicProgramming/Problems/One-Dimensional/256.paint-house.html","tags":["DP","Medium","1D"],"text":"Problem Statement There is a row of n houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by an n x 3 cost matrix costs . For example, costs[0][0] is the cost of painting house 0 with the color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Return the minimum cost to paint all houses . Example 1: ``` Input: costs = [[17,2,17],[16,16,5],[14,3,19]] Output: 10 Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue. Minimum cost: 2 + 5 + 3 = 10. ``` Example 2: ``` Input: costs = [[7,6,2]] Output: 2 ``` Constraints: costs.length == n costs[i].length == 3 1 <= n <= 100 1 <= costs[i][j] <= 20 Solution ```python class Solution: def minCost(self, costs: List[List[int]]) -> int: for i in range(len(costs) - 2, -1, -1): for j in range(0, 3): costs[i][j] += min(costs[i + 1][(j + 1) % 3], costs[i + 1][(j + 2) % 3]) return min(costs[0]) ```","title":"256.paint house"},{"location":"DynamicProgramming/Problems/One-Dimensional/256.paint-house.html#problem-statement","text":"There is a row of n houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by an n x 3 cost matrix costs . For example, costs[0][0] is the cost of painting house 0 with the color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Return the minimum cost to paint all houses . Example 1: ``` Input: costs = [[17,2,17],[16,16,5],[14,3,19]] Output: 10 Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue. Minimum cost: 2 + 5 + 3 = 10. ``` Example 2: ``` Input: costs = [[7,6,2]] Output: 2 ``` Constraints: costs.length == n costs[i].length == 3 1 <= n <= 100 1 <= costs[i][j] <= 20","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/One-Dimensional/256.paint-house.html#solution","text":"```python class Solution: def minCost(self, costs: List[List[int]]) -> int: for i in range(len(costs) - 2, -1, -1): for j in range(0, 3): costs[i][j] += min(costs[i + 1][(j + 1) % 3], costs[i + 1][(j + 2) % 3]) return min(costs[0]) ```","title":"Solution"},{"location":"DynamicProgramming/Problems/One-Dimensional/265.paint-house-ii.html","tags":["DP","Hard","1D"],"text":"Problem Statement There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by an n x k cost matrix costs. For example, costs[0][0] is the cost of painting house 0 with color 0 ; costs[1][2] is the cost of painting house 1 with color 2 , and so on... Return the minimum cost to paint all houses . Example 1: ``` Input: costs = [[1,5,3],[2,9,4]] Output: 5 Explanation: Paint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; Or paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5. ``` Example 2: ``` Input: costs = [[1,3],[2,4]] Output: 5 ``` Constraints: costs.length == n costs[i].length == k 1 <= n <= 100 2 <= k <= 20 1 <= costs[i][j] <= 20 Follow up: Could you solve it in O(nk) runtime? Solution ```python class Solution: def minCostII(self, costs: List[List[int]]) -> int: first_min = 0 second_min = 1 for i in range(0, len(costs[0])): if(costs[-1][i] < costs[-1][first_min]): second_min = first_min first_min = i elif(costs[-1][i] < costs[-1][second_min] and i != first_min): second_min = i print(first_min, second_min) for i in range(len(costs) - 2, -1, -1): new_first_min = None new_second_min = None for j in range(0, len(costs[0])): if(first_min != j): costs[i][j] += costs[i + 1][first_min] else: costs[i][j] += costs[i + 1][second_min] if(new_first_min == None or costs[i][j] < costs[i][new_first_min]): new_second_min = new_first_min new_first_min = j elif(new_second_min == None or costs[i][j] < costs[i][new_second_min]): new_second_min = j first_min = new_first_min second_min = new_second_min return min(costs[0]) ```","title":"265.paint house ii"},{"location":"DynamicProgramming/Problems/One-Dimensional/265.paint-house-ii.html#problem-statement","text":"There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by an n x k cost matrix costs. For example, costs[0][0] is the cost of painting house 0 with color 0 ; costs[1][2] is the cost of painting house 1 with color 2 , and so on... Return the minimum cost to paint all houses . Example 1: ``` Input: costs = [[1,5,3],[2,9,4]] Output: 5 Explanation: Paint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; Or paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5. ``` Example 2: ``` Input: costs = [[1,3],[2,4]] Output: 5 ``` Constraints: costs.length == n costs[i].length == k 1 <= n <= 100 2 <= k <= 20 1 <= costs[i][j] <= 20 Follow up: Could you solve it in O(nk) runtime?","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/One-Dimensional/265.paint-house-ii.html#solution","text":"```python class Solution: def minCostII(self, costs: List[List[int]]) -> int: first_min = 0 second_min = 1 for i in range(0, len(costs[0])): if(costs[-1][i] < costs[-1][first_min]): second_min = first_min first_min = i elif(costs[-1][i] < costs[-1][second_min] and i != first_min): second_min = i print(first_min, second_min) for i in range(len(costs) - 2, -1, -1): new_first_min = None new_second_min = None for j in range(0, len(costs[0])): if(first_min != j): costs[i][j] += costs[i + 1][first_min] else: costs[i][j] += costs[i + 1][second_min] if(new_first_min == None or costs[i][j] < costs[i][new_first_min]): new_second_min = new_first_min new_first_min = j elif(new_second_min == None or costs[i][j] < costs[i][new_second_min]): new_second_min = j first_min = new_first_min second_min = new_second_min return min(costs[0]) ```","title":"Solution"},{"location":"DynamicProgramming/Problems/One-Dimensional/487.Max-Consecutive-Ones-II.html","tags":["DP","Medium","1D"],"text":"Problem Statement Given a binary array nums , return the maximum number of consecutive 1 's in the array if you can flip at most one 0 . Example 1: ``` Input: nums = [1,0,1,1,0] Output: 4 Explanation: - If we flip the first zero, nums becomes [1,1,1,1,0] and we have 4 consecutive ones. - If we flip the second zero, nums becomes [1,0,1,1,1] and we have 3 consecutive ones. The max number of consecutive ones is 4. ``` Example 2: ``` Input: nums = [1,0,1,1,0,1] Output: 4 Explanation: - If we flip the first zero, nums becomes [1,1,1,1,0,1] and we have 4 consecutive ones. - If we flip the second zero, nums becomes [1,0,1,1,1,1] and we have 4 consecutive ones. The max number of consecutive ones is 4. ``` Constraints: 1 <= nums.length <= 10<sup>5</sup> nums[i] is either 0 or 1 . Follow up: What if the input numbers come in one by one as an infinite stream? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently? Solution python class Solution: def findMaxConsecutiveOnes(self, nums: List[int]) -> int: cur_index, next_index, ans = -1, None, 0 for i in range(len(nums)): if(nums[i] == 0): if(next_index == None): next_index = i else: cur_index, next_index = next_index, i ans = max(ans, i - cur_index) return ans","title":"487.Max Consecutive Ones II"},{"location":"DynamicProgramming/Problems/One-Dimensional/487.Max-Consecutive-Ones-II.html#problem-statement","text":"Given a binary array nums , return the maximum number of consecutive 1 's in the array if you can flip at most one 0 . Example 1: ``` Input: nums = [1,0,1,1,0] Output: 4 Explanation: - If we flip the first zero, nums becomes [1,1,1,1,0] and we have 4 consecutive ones. - If we flip the second zero, nums becomes [1,0,1,1,1] and we have 3 consecutive ones. The max number of consecutive ones is 4. ``` Example 2: ``` Input: nums = [1,0,1,1,0,1] Output: 4 Explanation: - If we flip the first zero, nums becomes [1,1,1,1,0,1] and we have 4 consecutive ones. - If we flip the second zero, nums becomes [1,0,1,1,1,1] and we have 4 consecutive ones. The max number of consecutive ones is 4. ``` Constraints: 1 <= nums.length <= 10<sup>5</sup> nums[i] is either 0 or 1 . Follow up: What if the input numbers come in one by one as an infinite stream? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently?","title":"Problem Statement"},{"location":"DynamicProgramming/Problems/One-Dimensional/487.Max-Consecutive-Ones-II.html#solution","text":"python class Solution: def findMaxConsecutiveOnes(self, nums: List[int]) -> int: cur_index, next_index, ans = -1, None, 0 for i in range(len(nums)): if(nums[i] == 0): if(next_index == None): next_index = i else: cur_index, next_index = next_index, i ans = max(ans, i - cur_index) return ans","title":"Solution"},{"location":"GFG-Contests/weekly-contest-103/K-periodic-circular-string.html","tags":["Strings","Contest","HashMap"],"text":"A K -periodic circular string is a circular string which remains same when it is rotated by K units. Given a circular string s , find whether there exists a permuation of s which is a K-periodic circular string and if it exists then find lexicographically smallest permuation of s which is a K-periodic circular string. Return empty string if there does not exist a valid permutation of s which is a K-periodic circular string. Note : You can rotate string in any direction. Example 1: ``` Input: s = \"abba\" K = 2 Output: abab Explanation: \"abab\" when rotated by 2 units remains same. ``` Example 2: ``` Input: s = \"abbbbbb\" K = 4 Output: -1 Explanation: No permuation of s can be a 4-periodic circular string. ``` Your Task: You don't need to read input or print anything. Your task is to complete the function kPeriodic() which takes the string s and integer K as input parameters and returns the lexicographically smallest permuation of s which is a K-periodic circular string if it exists, else returns an empty string, the driver code will print \"-1\" in that case. Expected Time Complexity: O(|s|) Expected Auxiliary Space: O(|s|) Constraints: 1 \u2264 |s| \u2264 10 5 1 \u2264 K \u2264 10 9 ```python class Solution: def kPeriodic(self, s, k): freq = [0] * 26 different_chars = 0 current_char = '' for char in s: freq[ord(char) - ord('a')] += 1 if(freq[ord(char) - ord('a')] == 1): different_chars += 1 current_char = 'a' size, index = 0, 0 result = ['-'] * len(s) while(result[index] == '-'): size += 1 result[index] = '.' index += k index %= len(s) for i in range(26): if(freq[i] % size != 0): return \"\" result = ['-'] * len(s) cnt, index, charindex = 0, 0, 0 while(cnt < len(s)): while(result[index] != '-'): index += 1 while(freq[charindex] == 0): charindex += 1 while(result[index] == '-'): cnt += 1 result[index] = chr(ord('a') + charindex) index += k index %= len(s) freq[charindex] -= size return ''.join(result) ```","title":"K-periodic Circular String"},{"location":"GFG-Contests/weekly-contest-103/Refueling.html","tags":["Math","Contest"],"text":"Problem Statement You're driving a car on the x-axis. But you ran out of fuel exactly at point X . Luckily, there are refueling stations. For any non-negative integer K , there is a refueling station at point 2 K . Find the position of your nearest refueling station. If there is more than 1 possible station, return the one present on the right. Solve Example 1: ``` Input: X = 3, Output: 4 Explanation: Nearest station from X = 3 is 2 and 1. Since 4 is present in the rightmost position therefore 4 is the answer. ``` Example 2: ``` Input: X = 2, Output: 2 Explanation: Nearest station from X = 2 is 2. ``` Your Task: The task is to complete the function refueling() which takes an integer X as input parameters and returns the position of the nearest refueling station Constraints: 1 \u2264 X \u2264 10 9 ```python class Solution: def refueling(self, position): last = 1 curr = 1 while(curr < position): last = curr curr *= 2 return curr if(abs(curr - position) <= abs(last - position)) else last ```","title":"Refueling"},{"location":"GFG-Contests/weekly-contest-103/Refueling.html#problem-statement","text":"You're driving a car on the x-axis. But you ran out of fuel exactly at point X . Luckily, there are refueling stations. For any non-negative integer K , there is a refueling station at point 2 K . Find the position of your nearest refueling station. If there is more than 1 possible station, return the one present on the right. Solve Example 1: ``` Input: X = 3, Output: 4 Explanation: Nearest station from X = 3 is 2 and 1. Since 4 is present in the rightmost position therefore 4 is the answer. ``` Example 2: ``` Input: X = 2, Output: 2 Explanation: Nearest station from X = 2 is 2. ``` Your Task: The task is to complete the function refueling() which takes an integer X as input parameters and returns the position of the nearest refueling station Constraints: 1 \u2264 X \u2264 10 9 ```python class Solution: def refueling(self, position): last = 1 curr = 1 while(curr < position): last = curr curr *= 2 return curr if(abs(curr - position) <= abs(last - position)) else last ```","title":"Problem Statement"},{"location":"Graphs/index.html","text":"Graphs This pages act as home page for Graph concepts Topics","title":"Home"},{"location":"Graphs/index.html#graphs","text":"This pages act as home page for Graph concepts","title":"Graphs"},{"location":"Graphs/index.html#topics","text":"","title":"Topics"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html","text":"Introduction It's a greedy Shortest Path Algorithm Helps to find shortest path from source to all vertices Applications Network Routing Protocols Transportation Planning Computer Networks Limitations It doesn't work for Negative weight cycles . Video Youtube Techdose Algorithm Maintain a SET of Processed Nodes Assign all Nodes with distance Value = Infinity Loop: (Until all vertices are Included) Pick min value vertex which is not already processed. Include this selected Node in Processed Set Update all the adjacent Node distances Pick min value vertex which is not already processed. If (New distance < old distance) then Update Else Skip Dijkstra's Algorithm Time Complexity O(V^2) Simple Implementation using Adj Matrix O(ElogV) (Adj List + min heap) Implementation (ElogV) Java Adj List, PriorityQueue Adj List, TreeSet java linenums=\"1\" class Solution { static int[] dijkstra(int n, ArrayList<ArrayList<ArrayList<Integer>>> adj, int s) { int[] distances = new int[n]; Arrays.fill(distances, Integer.MAX_VALUE); distances[s] = 0; Set<Integer> processed = new HashSet<Integer>(); Queue<Integer[]> queue = new PriorityQueue<>(new Comparator<Integer[]>(){ public int compare(Integer[] a, Integer[] b){ return Integer.compare(a[1], b[1]); } }); queue.add(new Integer[]{s, 0}); while(processed.size() < n - 1 && queue.size() > 0){ Integer[] vertex = queue.poll(); processed.add(vertex[0]); for(var v: adj.get(vertex[0])){ if(processed.contains(v.get(0))){ continue; } if(distances[v.get(0)] > distances[vertex[0]] + v.get(1)){ distances[v.get(0)] = distances[vertex[0]] + v.get(1); queue.add(new Integer[]{v.get(0), distances[v.get(0)]}); } } } return distances; } } java linenums=\"1\" class Node{ int index; int dist; Node(int index,int dist){ this.index = index; this.dist = dist; } } class Solution { //Function to find the shortest distance of all the vertices //from the source vertex S. static int[] dijkstra(int v, ArrayList<ArrayList<ArrayList<Integer>>> adj, int s) { int result[] = new int[v]; Node[] o = new Node[v]; TreeSet<Node> queue = new TreeSet<Node>(new Comparator<Node>(){ public int compare(Node n1,Node n2){ if(n1.dist == n2.dist){ return Integer.compare(n1.index,n2.index); } return Integer.compare(n1.dist,n2.dist); } }); for(int i = 0; i < v;i++){ result[i] = Integer.MAX_VALUE; int dist = Integer.MAX_VALUE; if(i == s){ dist = 0; } o[i] = new Node(i,dist); } queue.add(o[s]); while(!queue.isEmpty()){ var node = queue.pollFirst(); result[node.index] = node.dist; for(var u: adj.get(node.index)){ if(result[u.get(0)] > node.dist + u.get(1)){ o[u.get(0)].dist = node.dist + u.get(1); result[u.get(0)] = node.dist + u.get(1); queue.add(o[u.get(0)]); } } } return result; } } Python Using Heapq python linenums=\"1\" import heapq class Solution: def dijkstra(self, v, adj, s): distances = [float(\"Inf\")] * (v) distances[s] = 0 queue = [] heapq.heappush(queue, (0, s)) processed = set() while(queue and len(processed) < v - 1): dist, vertex = heapq.heappop(queue) processed.add(vertex) for child, distance in adj[vertex]: if(child in processed): continue; if(distances[child] > distance + dist): distances[child] = distance + dist heapq.heappush(queue, (distances[child], child)) return distances Practice Problems Airlines and Railways","title":"Dijkstra's Algorithm"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#introduction","text":"It's a greedy Shortest Path Algorithm Helps to find shortest path from source to all vertices","title":"Introduction"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#applications","text":"Network Routing Protocols Transportation Planning Computer Networks","title":"Applications"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#limitations","text":"It doesn't work for Negative weight cycles .","title":"Limitations"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#video","text":"Youtube Techdose","title":"Video"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#algorithm","text":"Maintain a SET of Processed Nodes Assign all Nodes with distance Value = Infinity Loop: (Until all vertices are Included) Pick min value vertex which is not already processed. Include this selected Node in Processed Set Update all the adjacent Node distances Pick min value vertex which is not already processed. If (New distance < old distance) then Update Else Skip Dijkstra's Algorithm","title":"Algorithm"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#time-complexity","text":"O(V^2) Simple Implementation using Adj Matrix O(ElogV) (Adj List + min heap)","title":"Time Complexity"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#implementation-elogv","text":"","title":"Implementation (ElogV)"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#java","text":"Adj List, PriorityQueue Adj List, TreeSet java linenums=\"1\" class Solution { static int[] dijkstra(int n, ArrayList<ArrayList<ArrayList<Integer>>> adj, int s) { int[] distances = new int[n]; Arrays.fill(distances, Integer.MAX_VALUE); distances[s] = 0; Set<Integer> processed = new HashSet<Integer>(); Queue<Integer[]> queue = new PriorityQueue<>(new Comparator<Integer[]>(){ public int compare(Integer[] a, Integer[] b){ return Integer.compare(a[1], b[1]); } }); queue.add(new Integer[]{s, 0}); while(processed.size() < n - 1 && queue.size() > 0){ Integer[] vertex = queue.poll(); processed.add(vertex[0]); for(var v: adj.get(vertex[0])){ if(processed.contains(v.get(0))){ continue; } if(distances[v.get(0)] > distances[vertex[0]] + v.get(1)){ distances[v.get(0)] = distances[vertex[0]] + v.get(1); queue.add(new Integer[]{v.get(0), distances[v.get(0)]}); } } } return distances; } } java linenums=\"1\" class Node{ int index; int dist; Node(int index,int dist){ this.index = index; this.dist = dist; } } class Solution { //Function to find the shortest distance of all the vertices //from the source vertex S. static int[] dijkstra(int v, ArrayList<ArrayList<ArrayList<Integer>>> adj, int s) { int result[] = new int[v]; Node[] o = new Node[v]; TreeSet<Node> queue = new TreeSet<Node>(new Comparator<Node>(){ public int compare(Node n1,Node n2){ if(n1.dist == n2.dist){ return Integer.compare(n1.index,n2.index); } return Integer.compare(n1.dist,n2.dist); } }); for(int i = 0; i < v;i++){ result[i] = Integer.MAX_VALUE; int dist = Integer.MAX_VALUE; if(i == s){ dist = 0; } o[i] = new Node(i,dist); } queue.add(o[s]); while(!queue.isEmpty()){ var node = queue.pollFirst(); result[node.index] = node.dist; for(var u: adj.get(node.index)){ if(result[u.get(0)] > node.dist + u.get(1)){ o[u.get(0)].dist = node.dist + u.get(1); result[u.get(0)] = node.dist + u.get(1); queue.add(o[u.get(0)]); } } } return result; } }","title":"Java"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#python","text":"Using Heapq python linenums=\"1\" import heapq class Solution: def dijkstra(self, v, adj, s): distances = [float(\"Inf\")] * (v) distances[s] = 0 queue = [] heapq.heappush(queue, (0, s)) processed = set() while(queue and len(processed) < v - 1): dist, vertex = heapq.heappop(queue) processed.add(vertex) for child, distance in adj[vertex]: if(child in processed): continue; if(distances[child] > distance + dist): distances[child] = distance + dist heapq.heappush(queue, (distances[child], child)) return distances","title":"Python"},{"location":"Graphs/ShortestPathAlgorithms/Dijkstra%27s.html#practice-problems","text":"Airlines and Railways","title":"Practice Problems"},{"location":"MyProgress/index.html","text":"Profiles GeeksForGeeks Leetcode Codeforces Hackerrank Current Month Problems Solved Month Wise Problems Solved Topic Wise Problems Solved Problems Solved Per Platform Problems Solved per difficulty in Leetcode","title":"Progress Tracking"},{"location":"MyProgress/index.html#profiles","text":"GeeksForGeeks Leetcode Codeforces Hackerrank","title":"Profiles"},{"location":"MyProgress/index.html#current-month-problems-solved","text":"","title":"Current Month Problems Solved"},{"location":"MyProgress/index.html#month-wise-problems-solved","text":"","title":"Month Wise Problems Solved"},{"location":"MyProgress/index.html#topic-wise-problems-solved","text":"","title":"Topic Wise Problems Solved"},{"location":"MyProgress/index.html#problems-solved-per-platform","text":"","title":"Problems Solved Per Platform"},{"location":"MyProgress/index.html#problems-solved-per-difficulty-in-leetcode","text":"","title":"Problems Solved per difficulty in Leetcode"},{"location":"MyProgress/Contests.html","text":"GFG Weekly Coding Contest GFG Weekly Contest 102 - 14th May 2023 Solved 2 Problems 1st is simple sort and difference 2nd is tree based finding sum of cousin nodes 3rd problem seemed to be Graph based and shortest path, don't remember algorithms Contest Link","title":"Contests"},{"location":"MyProgress/Contests.html#gfg-weekly-coding-contest","text":"GFG Weekly Contest 102 - 14th May 2023 Solved 2 Problems 1st is simple sort and difference 2nd is tree based finding sum of cousin nodes 3rd problem seemed to be Graph based and shortest path, don't remember algorithms Contest Link","title":"GFG Weekly Coding Contest"},{"location":"MyProgress/May-logs.html","text":"Daily Updates 14/05/2023 Created a site to track Progress. Solved 2 problems in codeforces. Solved JS 30days challenge problem in leetcode Participated in GFG Contest and was able to solve 2 problems. 22/05/2023 Solved a problem on Spoj (topic - Dp on Trees) Spent 1 hour on udemy DP course Solved problems of GFG Weekly Contest 103 Solved 1 problem on Leetcode - Dp on Trees","title":"May logs"},{"location":"MyProgress/May-logs.html#daily-updates","text":"14/05/2023 Created a site to track Progress. Solved 2 problems in codeforces. Solved JS 30days challenge problem in leetcode Participated in GFG Contest and was able to solve 2 problems. 22/05/2023 Solved a problem on Spoj (topic - Dp on Trees) Spent 1 hour on udemy DP course Solved problems of GFG Weekly Contest 103 Solved 1 problem on Leetcode - Dp on Trees","title":"Daily Updates"}]}